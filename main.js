/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImmersePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  pomodoroWorkMinutes: 25,
  pomodoroBreakMinutes: 5,
  longBreakMinutes: 15,
  longBreakInterval: 4,
  enableSounds: true,
  enableCelebrations: true,
  defaultEstimateMinutes: 30,
  lists: [
    { id: "work", name: "Work", color: "#6366f1", icon: "\u{1F4BC}" },
    { id: "personal", name: "Personal", color: "#22c55e", icon: "\u{1F3E0}" },
    { id: "learning", name: "Learning", color: "#f59e0b", icon: "\u{1F4DA}" }
  ],
  autoStartBreak: true,
  tickSoundEnabled: false,
  // Daily note logging
  logToDaily: false,
  // Task reminders
  enableReminders: true,
  defaultReminderMinutes: 15
};
var DEFAULT_DATA = {
  tasks: [],
  completedToday: 0,
  totalFocusMinutesToday: 0,
  streak: 0,
  lastActiveDate: "",
  pomodorosCompleted: 0,
  dailyStats: [],
  completedTasksArchive: []
};
var VIEW_TYPE_IMMERSE = "immerse-view";
var CELEBRATION_MESSAGES = [
  { emoji: "\u{1F4A5}", message: "Crushed it!" },
  { emoji: "\u{1F525}", message: "On fire!" },
  { emoji: "\u26A1", message: "Lightning fast!" },
  { emoji: "\u{1F3AF}", message: "Bullseye!" },
  { emoji: "\u{1F680}", message: "Blasting through!" },
  { emoji: "\u{1F4AA}", message: "Strong work!" },
  { emoji: "\u{1F31F}", message: "Stellar!" },
  { emoji: "\u2728", message: "Brilliant!" },
  { emoji: "\u{1F3C6}", message: "Champion!" },
  { emoji: "\u{1F389}", message: "Well done!" }
];
var EARLY_FINISH_MESSAGES = [
  { emoji: "\u26A1", message: "Speed demon! Finished early!" },
  { emoji: "\u{1F3CE}\uFE0F", message: "Faster than expected!" },
  { emoji: "\u{1F3AF}", message: "Under budget! Nice work!" }
];
var OVERTIME_MESSAGES = [
  { emoji: "\u{1F4AA}", message: "Persistence pays off!" },
  { emoji: "\u{1F3C3}", message: "Marathon runner!" },
  { emoji: "\u{1F525}", message: "The grind is real!" }
];

// src/view.ts
var import_obsidian2 = require("obsidian");

// src/modals.ts
var import_obsidian = require("obsidian");
var EMOJI_KEYWORDS = {
  "\u{1F4BC}": "briefcase work business office job",
  "\u{1F3E0}": "home house",
  "\u{1F4DA}": "books study read library",
  "\u{1F3AF}": "target goal aim dart",
  "\u2705": "check mark done complete checkbox tick",
  "\u{1F4DD}": "memo note write pencil",
  "\u{1F4A1}": "light bulb idea",
  "\u{1F525}": "fire hot flame",
  "\u26A1": "lightning bolt electric zap",
  "\u{1F3A8}": "art paint palette",
  "\u{1F3C6}": "trophy award win",
  "\u{1F4AA}": "muscle strong flex",
  "\u{1F680}": "rocket ship launch",
  "\u{1F4CA}": "chart graph data",
  "\u23F0": "clock time alarm",
  "\u{1F4B0}": "money bag cash dollar",
  "\u{1F600}": "smile happy face grin",
  "\u{1F603}": "smile happy grin",
  "\u{1F604}": "smile happy laugh",
  "\u{1F601}": "grin smile happy",
  "\u{1F606}": "laugh smile happy",
  "\u{1F605}": "sweat smile nervous",
  "\u{1F923}": "laugh rolling floor",
  "\u{1F602}": "tears joy laugh cry",
  "\u{1F642}": "smile happy slight",
  "\u{1F643}": "upside down smile",
  "\u{1F609}": "wink smile flirt",
  "\u{1F60A}": "blush smile happy",
  "\u{1F607}": "angel halo smile",
  "\u{1F970}": "love hearts smile",
  "\u{1F60D}": "love heart eyes smile",
  "\u{1F929}": "star eyes excited",
  "\u{1F618}": "kiss love heart",
  "\u{1F617}": "kiss love",
  "\u{1F61A}": "kiss love",
  "\u{1F619}": "kiss love smile",
  "\u{1F972}": "smile tear cry happy",
  "\u{1F60B}": "yum delicious smile",
  "\u{1F61B}": "tongue playful",
  "\u{1F61C}": "wink tongue playful",
  "\u{1F92A}": "crazy wild eyes",
  "\u{1F61D}": "tongue eyes squint",
  "\u{1F911}": "money dollar rich",
  "\u{1F917}": "hug smile",
  "\u{1F92D}": "hand over mouth giggle",
  "\u{1F92B}": "shush quiet secret",
  "\u{1F914}": "think hmm wonder",
  "\u{1F910}": "zipper mouth secret",
  "\u{1F928}": "eyebrow raised skeptical",
  "\u{1F610}": "neutral meh",
  "\u{1F611}": "expressionless blank",
  "\u{1F636}": "no mouth silent",
  "\u{1F60F}": "smirk confident",
  "\u{1F612}": "unamused annoyed",
  "\u{1F644}": "eye roll annoyed",
  "\u{1F62C}": "grimace awkward",
  "\u{1F925}": "liar lying pinocchio",
  "\u{1F60C}": "relieved content",
  "\u{1F614}": "sad pensive",
  "\u{1F62A}": "sleepy tired",
  "\u{1F924}": "drool sleep",
  "\u{1F634}": "sleep zzz",
  "\u{1F637}": "mask sick medical",
  "\u{1F912}": "sick thermometer",
  "\u{1F915}": "injured bandage",
  "\u{1F922}": "nausea sick",
  "\u{1F92E}": "vomit sick",
  "\u{1F927}": "sneeze sick tissue",
  "\u{1F975}": "hot sweat",
  "\u{1F976}": "cold freeze",
  "\u{1F60E}": "cool sunglasses",
  "\u{1F913}": "nerd glasses",
  "\u{1F9D0}": "monocle fancy",
  "\u{1F615}": "confused uncertain",
  "\u{1F61F}": "worried concerned",
  "\u{1F641}": "frown sad",
  "\u2639\uFE0F": "frown sad",
  "\u{1F62E}": "wow surprised",
  "\u{1F62F}": "surprised shocked",
  "\u{1F632}": "shocked astonished",
  "\u{1F633}": "flushed embarrassed",
  "\u{1F97A}": "pleading puppy eyes",
  "\u{1F626}": "frown worried",
  "\u{1F627}": "anguished worried",
  "\u{1F628}": "fearful scared",
  "\u{1F630}": "anxious sweat",
  "\u{1F625}": "sad sweat",
  "\u{1F622}": "cry tear sad",
  "\u{1F62D}": "cry tears sob",
  "\u{1F631}": "scream fear",
  "\u{1F616}": "confounded",
  "\u{1F623}": "persevere struggle",
  "\u{1F61E}": "disappointed sad",
  "\u{1F613}": "downcast sweat",
  "\u{1F629}": "weary tired",
  "\u{1F62B}": "tired exhausted",
  "\u{1F971}": "yawn tired",
  "\u{1F624}": "triumph proud",
  "\u{1F621}": "angry mad rage",
  "\u{1F620}": "angry mad",
  "\u{1F92C}": "cursing swearing angry",
  "\u{1F608}": "devil smiling evil",
  "\u{1F47F}": "devil angry evil",
  "\u{1F480}": "skull death",
  "\u2620\uFE0F": "skull crossbones death",
  "\u{1F4A9}": "poop poo",
  "\u{1F921}": "clown funny",
  "\u{1F479}": "ogre monster",
  "\u{1F47A}": "goblin monster",
  "\u{1F47B}": "ghost boo",
  "\u{1F47D}": "alien extraterrestrial",
  "\u{1F47E}": "alien monster game",
  "\u{1F916}": "robot bot",
  "\u2764\uFE0F": "red heart love",
  "\u{1F9E1}": "orange heart love",
  "\u{1F49B}": "yellow heart love",
  "\u{1F49A}": "green heart love",
  "\u{1F499}": "blue heart love",
  "\u{1F49C}": "purple heart love",
  "\u{1F90E}": "brown heart love",
  "\u{1F5A4}": "black heart love",
  "\u{1F90D}": "white heart love",
  "\u{1F494}": "broken heart sad",
  "\u2763\uFE0F": "heart exclamation love",
  "\u{1F495}": "two hearts love",
  "\u{1F49E}": "revolving hearts love",
  "\u{1F493}": "beating heart love",
  "\u{1F497}": "growing heart love",
  "\u{1F496}": "sparkling heart love",
  "\u{1F498}": "arrow heart love cupid",
  "\u{1F49D}": "heart box gift love",
  "\u{1F49F}": "heart decoration love",
  "\u2764\uFE0F\u200D\u{1F525}": "heart fire love passion",
  "\u2764\uFE0F\u200D\u{1FA79}": "heart bandage healing",
  "\u{1F48C}": "love letter heart",
  "\u{1F48B}": "kiss lips",
  "\u{1F491}": "couple love kiss",
  "\u{1F48F}": "kiss couple love",
  "\u{1F44B}": "wave hand hello goodbye",
  "\u{1F91A}": "raised hand back",
  "\u{1F590}\uFE0F": "hand fingers spread",
  "\u270B": "raised hand stop",
  "\u{1F596}": "vulcan salute spock",
  "\u{1F44C}": "ok okay hand",
  "\u{1F90C}": "pinched fingers italian",
  "\u{1F90F}": "pinching hand small",
  "\u270C\uFE0F": "peace victory hand",
  "\u{1F91E}": "crossed fingers luck",
  "\u{1F91F}": "love you hand",
  "\u{1F918}": "rock on horns",
  "\u{1F919}": "call me hang loose",
  "\u{1F448}": "left point finger",
  "\u{1F449}": "right point finger",
  "\u{1F446}": "up point finger",
  "\u{1F595}": "middle finger rude",
  "\u{1F447}": "down point finger",
  "\u261D\uFE0F": "up point finger",
  "\u{1F44D}": "thumbs up yes good",
  "\u{1F44E}": "thumbs down no bad",
  "\u270A": "fist hand",
  "\u{1F44A}": "fist bump punch",
  "\u{1F91B}": "left fist bump",
  "\u{1F91C}": "right fist bump",
  "\u{1F44F}": "clap applause",
  "\u{1F64C}": "raising hands celebration",
  "\u{1F450}": "open hands",
  "\u{1F932}": "palms together pray",
  "\u{1F91D}": "handshake deal",
  "\u{1F64F}": "pray please thank",
  "\u270D\uFE0F": "writing hand",
  "\u{1F485}": "nail polish manicure",
  "\u{1F933}": "selfie camera phone",
  "\u{1F436}": "dog puppy pet",
  "\u{1F431}": "cat kitty pet",
  "\u{1F42D}": "mouse rat",
  "\u{1F439}": "hamster pet",
  "\u{1F430}": "rabbit bunny",
  "\u{1F98A}": "fox",
  "\u{1F43B}": "bear",
  "\u{1F43C}": "panda bear",
  "\u{1F428}": "koala bear",
  "\u{1F42F}": "tiger face",
  "\u{1F981}": "lion face",
  "\u{1F42E}": "cow face",
  "\u{1F437}": "pig face",
  "\u{1F438}": "frog face",
  "\u{1F435}": "monkey face",
  "\u{1F34E}": "apple red fruit",
  "\u{1F34A}": "orange fruit",
  "\u{1F34B}": "lemon fruit",
  "\u{1F34C}": "banana fruit",
  "\u{1F349}": "watermelon fruit",
  "\u{1F347}": "grapes fruit",
  "\u{1F353}": "strawberry fruit",
  "\u{1F352}": "cherry fruit",
  "\u{1F351}": "peach fruit",
  "\u{1F96D}": "mango fruit",
  "\u{1F34D}": "pineapple fruit",
  "\u{1F965}": "coconut fruit",
  "\u{1F95D}": "kiwi fruit",
  "\u{1F345}": "tomato vegetable",
  "\u{1F951}": "avocado fruit",
  "\u{1F35E}": "bread food",
  "\u26BD": "soccer ball football",
  "\u{1F3C0}": "basketball ball",
  "\u{1F3C8}": "american football",
  "\u26BE": "baseball ball",
  "\u{1F3BE}": "tennis ball",
  "\u{1F3D0}": "volleyball ball",
  "\u{1F697}": "car auto vehicle",
  "\u{1F695}": "taxi car",
  "\u{1F699}": "suv car vehicle",
  "\u{1F68C}": "bus vehicle",
  "\u{1F68E}": "trolleybus bus",
  "\u{1F3CE}\uFE0F": "racing car fast",
  "\u{1F693}": "police car cop",
  "\u{1F691}": "ambulance emergency",
  "\u{1F692}": "fire truck engine",
  "\u{1F6B2}": "bicycle bike",
  "\u2708\uFE0F": "airplane plane flight",
  "\u{1F4BB}": "laptop computer",
  "\u2328\uFE0F": "keyboard computer",
  "\u{1F5B1}\uFE0F": "mouse computer",
  "\u{1F5A5}\uFE0F": "desktop computer",
  "\u{1F5A8}\uFE0F": "printer",
  "\u{1F4F1}": "phone mobile iphone",
  "\u{1F4DE}": "phone telephone",
  "\u260E\uFE0F": "telephone phone",
  "\u{1F4FA}": "tv television",
  "\u{1F4FB}": "radio",
  "\u{1F4C1}": "folder file",
  "\u{1F4C2}": "open folder file",
  "\u{1F4C5}": "calendar date",
  "\u{1F4C6}": "calendar date",
  "\u{1F4C8}": "chart up graph",
  "\u{1F4C9}": "chart down graph",
  "\u{1F4CC}": "pushpin pin",
  "\u{1F4CD}": "pin location map",
  "\u{1F4CE}": "paperclip clip",
  "\u{1F3B5}": "music note",
  "\u{1F3B6}": "music notes",
  "\u{1F3BC}": "musical score",
  "\u{1F3B9}": "piano keyboard music",
  "\u{1F3B8}": "guitar music",
  "\u{1F3BA}": "trumpet music",
  "\u{1F3B7}": "saxophone music",
  "\u{1F941}": "drum music",
  "\u{1F3A4}": "microphone mic sing",
  "\u{1F3A7}": "headphones music",
  "\u{1F50A}": "speaker loud volume",
  "\u274C": "cross x no cancel",
  "\u26A0\uFE0F": "warning caution alert",
  "\u{1F534}": "red circle",
  "\u{1F7E2}": "green circle",
  "\u{1F535}": "blue circle",
  "\u{1F7E1}": "yellow circle",
  "\u{1F7E3}": "purple circle",
  "\u26AB": "black circle",
  "\u26AA": "white circle",
  "\u{1F7E4}": "brown circle",
  "\u{1F53A}": "triangle red up",
  "\u{1F53B}": "triangle red down",
  "\u{1F538}": "diamond orange small",
  "\u{1F539}": "diamond blue small",
  "\u{1F536}": "diamond orange large",
  "\u{1F537}": "diamond blue large"
};
var EMOJI_CATEGORIES = {
  "\u2B50 Frequently Used": ["\u{1F4BC}", "\u{1F3E0}", "\u{1F4DA}", "\u{1F3AF}", "\u2705", "\u{1F4DD}", "\u{1F4A1}", "\u{1F525}", "\u26A1", "\u{1F3A8}", "\u{1F3C6}", "\u{1F4AA}", "\u{1F680}", "\u{1F4CA}", "\u23F0", "\u{1F4B0}"],
  "\u{1F600} Smileys & Emotion": ["\u{1F600}", "\u{1F603}", "\u{1F604}", "\u{1F601}", "\u{1F606}", "\u{1F605}", "\u{1F923}", "\u{1F602}", "\u{1F642}", "\u{1F643}", "\u{1F609}", "\u{1F60A}", "\u{1F607}", "\u{1F970}", "\u{1F60D}", "\u{1F929}", "\u{1F618}", "\u{1F617}", "\u{1F61A}", "\u{1F619}", "\u{1F972}", "\u{1F60B}", "\u{1F61B}", "\u{1F61C}", "\u{1F92A}", "\u{1F61D}", "\u{1F911}", "\u{1F917}", "\u{1F92D}", "\u{1F92B}", "\u{1F914}", "\u{1F910}", "\u{1F928}", "\u{1F610}", "\u{1F611}", "\u{1F636}", "\u{1F60F}", "\u{1F612}", "\u{1F644}", "\u{1F62C}", "\u{1F925}", "\u{1F60C}", "\u{1F614}", "\u{1F62A}", "\u{1F924}", "\u{1F634}", "\u{1F637}", "\u{1F912}", "\u{1F915}", "\u{1F922}", "\u{1F92E}", "\u{1F927}", "\u{1F975}", "\u{1F976}", "\u{1F60E}", "\u{1F913}", "\u{1F9D0}", "\u{1F615}", "\u{1F61F}", "\u{1F641}", "\u2639\uFE0F", "\u{1F62E}", "\u{1F62F}", "\u{1F632}", "\u{1F633}", "\u{1F97A}", "\u{1F626}", "\u{1F627}", "\u{1F628}", "\u{1F630}", "\u{1F625}", "\u{1F622}", "\u{1F62D}", "\u{1F631}", "\u{1F616}", "\u{1F623}", "\u{1F61E}", "\u{1F613}", "\u{1F629}", "\u{1F62B}", "\u{1F971}", "\u{1F624}", "\u{1F621}", "\u{1F620}", "\u{1F92C}", "\u{1F608}", "\u{1F47F}", "\u{1F480}", "\u2620\uFE0F", "\u{1F4A9}", "\u{1F921}", "\u{1F479}", "\u{1F47A}", "\u{1F47B}", "\u{1F47D}", "\u{1F47E}", "\u{1F916}"],
  "\u2764\uFE0F Hearts & Love": ["\u2764\uFE0F", "\u{1F9E1}", "\u{1F49B}", "\u{1F49A}", "\u{1F499}", "\u{1F49C}", "\u{1F90E}", "\u{1F5A4}", "\u{1F90D}", "\u{1F494}", "\u2763\uFE0F", "\u{1F495}", "\u{1F49E}", "\u{1F493}", "\u{1F497}", "\u{1F496}", "\u{1F498}", "\u{1F49D}", "\u{1F49F}", "\u2764\uFE0F\u200D\u{1F525}", "\u2764\uFE0F\u200D\u{1FA79}", "\u{1F48C}", "\u{1F48B}", "\u{1F491}", "\u{1F48F}", "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F468}", "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F468}", "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F469}"],
  "\u{1F464} People & Body": ["\u{1F44B}", "\u{1F91A}", "\u{1F590}\uFE0F", "\u270B", "\u{1F596}", "\u{1F44C}", "\u{1F90C}", "\u{1F90F}", "\u270C\uFE0F", "\u{1F91E}", "\u{1F91F}", "\u{1F918}", "\u{1F919}", "\u{1F448}", "\u{1F449}", "\u{1F446}", "\u{1F595}", "\u{1F447}", "\u261D\uFE0F", "\u{1F44D}", "\u{1F44E}", "\u270A", "\u{1F44A}", "\u{1F91B}", "\u{1F91C}", "\u{1F44F}", "\u{1F64C}", "\u{1F450}", "\u{1F932}", "\u{1F91D}", "\u{1F64F}", "\u270D\uFE0F", "\u{1F485}", "\u{1F933}", "\u{1F4AA}", "\u{1F9BE}", "\u{1F9BF}", "\u{1F9B5}", "\u{1F9B6}", "\u{1F442}", "\u{1F9BB}", "\u{1F443}", "\u{1F9E0}", "\u{1FAC0}", "\u{1FAC1}", "\u{1F9B7}", "\u{1F9B4}", "\u{1F440}", "\u{1F441}\uFE0F", "\u{1F445}", "\u{1F444}", "\u{1F476}", "\u{1F9D2}", "\u{1F466}", "\u{1F467}", "\u{1F9D1}", "\u{1F468}", "\u{1F469}", "\u{1F9D4}", "\u{1F9D1}\u200D\u{1F9B0}", "\u{1F468}\u200D\u{1F9B0}", "\u{1F469}\u200D\u{1F9B0}", "\u{1F9D1}\u200D\u{1F9B1}", "\u{1F468}\u200D\u{1F9B1}", "\u{1F469}\u200D\u{1F9B1}", "\u{1F9D1}\u200D\u{1F9B3}", "\u{1F468}\u200D\u{1F9B3}", "\u{1F469}\u200D\u{1F9B3}", "\u{1F9D1}\u200D\u{1F9B2}", "\u{1F468}\u200D\u{1F9B2}", "\u{1F469}\u200D\u{1F9B2}", "\u{1F471}", "\u{1F471}\u200D\u2642\uFE0F", "\u{1F471}\u200D\u2640\uFE0F", "\u{1F9D3}", "\u{1F474}", "\u{1F475}", "\u{1F64D}", "\u{1F64D}\u200D\u2642\uFE0F", "\u{1F64D}\u200D\u2640\uFE0F", "\u{1F64E}", "\u{1F64E}\u200D\u2642\uFE0F", "\u{1F64E}\u200D\u2640\uFE0F", "\u{1F645}", "\u{1F645}\u200D\u2642\uFE0F", "\u{1F645}\u200D\u2640\uFE0F", "\u{1F646}", "\u{1F646}\u200D\u2642\uFE0F", "\u{1F646}\u200D\u2640\uFE0F", "\u{1F481}", "\u{1F481}\u200D\u2642\uFE0F", "\u{1F481}\u200D\u2640\uFE0F", "\u{1F64B}", "\u{1F64B}\u200D\u2642\uFE0F", "\u{1F64B}\u200D\u2640\uFE0F", "\u{1F9CF}", "\u{1F9CF}\u200D\u2642\uFE0F", "\u{1F9CF}\u200D\u2640\uFE0F", "\u{1F647}", "\u{1F647}\u200D\u2642\uFE0F", "\u{1F647}\u200D\u2640\uFE0F", "\u{1F926}", "\u{1F926}\u200D\u2642\uFE0F", "\u{1F926}\u200D\u2640\uFE0F", "\u{1F937}", "\u{1F937}\u200D\u2642\uFE0F", "\u{1F937}\u200D\u2640\uFE0F"],
  "\u{1F436} Animals & Nature": ["\u{1F436}", "\u{1F431}", "\u{1F42D}", "\u{1F439}", "\u{1F430}", "\u{1F98A}", "\u{1F43B}", "\u{1F43C}", "\u{1F428}", "\u{1F42F}", "\u{1F981}", "\u{1F42E}", "\u{1F437}", "\u{1F43D}", "\u{1F438}", "\u{1F435}", "\u{1F648}", "\u{1F649}", "\u{1F64A}", "\u{1F412}", "\u{1F414}", "\u{1F427}", "\u{1F426}", "\u{1F424}", "\u{1F423}", "\u{1F425}", "\u{1F986}", "\u{1F985}", "\u{1F989}", "\u{1F987}", "\u{1F43A}", "\u{1F417}", "\u{1F434}", "\u{1F984}", "\u{1F41D}", "\u{1F41B}", "\u{1F98B}", "\u{1F40C}", "\u{1F41E}", "\u{1F41C}", "\u{1F99F}", "\u{1F997}", "\u{1F577}\uFE0F", "\u{1F578}\uFE0F", "\u{1F982}", "\u{1F422}", "\u{1F40D}", "\u{1F98E}", "\u{1F996}", "\u{1F995}", "\u{1F419}", "\u{1F991}", "\u{1F990}", "\u{1F99E}", "\u{1F980}", "\u{1F421}", "\u{1F420}", "\u{1F41F}", "\u{1F42C}", "\u{1F433}", "\u{1F40B}", "\u{1F988}", "\u{1F40A}", "\u{1F405}", "\u{1F406}", "\u{1F993}", "\u{1F98D}", "\u{1F9A7}", "\u{1F418}", "\u{1F99B}", "\u{1F98F}", "\u{1F42A}", "\u{1F42B}", "\u{1F992}", "\u{1F998}", "\u{1F403}", "\u{1F402}", "\u{1F404}", "\u{1F40E}", "\u{1F416}", "\u{1F40F}", "\u{1F411}", "\u{1F999}", "\u{1F410}", "\u{1F98C}", "\u{1F415}", "\u{1F429}", "\u{1F9AE}", "\u{1F415}\u200D\u{1F9BA}", "\u{1F408}", "\u{1F408}\u200D\u2B1B", "\u{1F413}", "\u{1F983}", "\u{1F99A}", "\u{1F99C}", "\u{1F9A2}", "\u{1F9A9}", "\u{1F54A}\uFE0F", "\u{1F407}", "\u{1F99D}", "\u{1F9A8}", "\u{1F9A1}", "\u{1F9A6}", "\u{1F9A5}", "\u{1F401}", "\u{1F400}", "\u{1F43F}\uFE0F", "\u{1F994}", "\u{1F332}", "\u{1F333}", "\u{1F334}", "\u{1F331}", "\u{1F33F}", "\u2618\uFE0F", "\u{1F340}", "\u{1F38D}", "\u{1F38B}", "\u{1F343}", "\u{1F342}", "\u{1F341}", "\u{1F344}", "\u{1F33E}", "\u{1F490}", "\u{1F337}", "\u{1F339}", "\u{1F940}", "\u{1F33A}", "\u{1F338}", "\u{1F33C}", "\u{1F33B}", "\u{1F31E}", "\u{1F31D}", "\u{1F31B}", "\u{1F31C}", "\u{1F31A}", "\u{1F315}", "\u{1F316}", "\u{1F317}", "\u{1F318}", "\u{1F311}", "\u{1F312}", "\u{1F313}", "\u{1F314}", "\u{1F319}", "\u{1F30E}", "\u{1F30D}", "\u{1F30F}", "\u{1FA90}", "\u{1F4AB}", "\u2B50", "\u{1F31F}", "\u2728", "\u26A1", "\u2604\uFE0F", "\u{1F4A5}", "\u{1F525}", "\u{1F32A}\uFE0F", "\u{1F308}", "\u2600\uFE0F", "\u{1F324}\uFE0F", "\u26C5", "\u{1F325}\uFE0F", "\u2601\uFE0F", "\u{1F326}\uFE0F", "\u{1F327}\uFE0F", "\u26C8\uFE0F", "\u{1F329}\uFE0F", "\u{1F328}\uFE0F", "\u2744\uFE0F", "\u2603\uFE0F", "\u26C4", "\u{1F32C}\uFE0F", "\u{1F4A8}", "\u{1F4A7}", "\u{1F4A6}", "\u2614", "\u2602\uFE0F", "\u{1F30A}", "\u{1F32B}\uFE0F"],
  "\u{1F34E} Food & Drink": ["\u{1F347}", "\u{1F348}", "\u{1F349}", "\u{1F34A}", "\u{1F34B}", "\u{1F34C}", "\u{1F34D}", "\u{1F96D}", "\u{1F34E}", "\u{1F34F}", "\u{1F350}", "\u{1F351}", "\u{1F352}", "\u{1F353}", "\u{1FAD0}", "\u{1F95D}", "\u{1F345}", "\u{1FAD2}", "\u{1F965}", "\u{1F951}", "\u{1F346}", "\u{1F954}", "\u{1F955}", "\u{1F33D}", "\u{1F336}\uFE0F", "\u{1FAD1}", "\u{1F952}", "\u{1F96C}", "\u{1F966}", "\u{1F9C4}", "\u{1F9C5}", "\u{1F344}", "\u{1F95C}", "\u{1F330}", "\u{1F35E}", "\u{1F950}", "\u{1F956}", "\u{1FAD3}", "\u{1F968}", "\u{1F96F}", "\u{1F95E}", "\u{1F9C7}", "\u{1F9C0}", "\u{1F356}", "\u{1F357}", "\u{1F969}", "\u{1F953}", "\u{1F354}", "\u{1F35F}", "\u{1F355}", "\u{1F32D}", "\u{1F96A}", "\u{1F32E}", "\u{1F32F}", "\u{1FAD4}", "\u{1F959}", "\u{1F9C6}", "\u{1F95A}", "\u{1F373}", "\u{1F958}", "\u{1F372}", "\u{1FAD5}", "\u{1F963}", "\u{1F957}", "\u{1F37F}", "\u{1F9C8}", "\u{1F9C2}", "\u{1F96B}", "\u{1F371}", "\u{1F358}", "\u{1F359}", "\u{1F35A}", "\u{1F35B}", "\u{1F35C}", "\u{1F35D}", "\u{1F360}", "\u{1F362}", "\u{1F363}", "\u{1F364}", "\u{1F365}", "\u{1F96E}", "\u{1F361}", "\u{1F95F}", "\u{1F960}", "\u{1F961}", "\u{1F980}", "\u{1F99E}", "\u{1F990}", "\u{1F991}", "\u{1F9AA}", "\u{1F366}", "\u{1F367}", "\u{1F368}", "\u{1F369}", "\u{1F36A}", "\u{1F382}", "\u{1F370}", "\u{1F9C1}", "\u{1F967}", "\u{1F36B}", "\u{1F36C}", "\u{1F36D}", "\u{1F36E}", "\u{1F36F}", "\u{1F37C}", "\u{1F95B}", "\u2615", "\u{1FAD6}", "\u{1F375}", "\u{1F376}", "\u{1F37E}", "\u{1F377}", "\u{1F378}", "\u{1F379}", "\u{1F37A}", "\u{1F37B}", "\u{1F942}", "\u{1F943}", "\u{1F964}", "\u{1F9CB}", "\u{1F9C3}", "\u{1F9C9}", "\u{1F9CA}"],
  "\u26BD Activities & Sports": ["\u26BD", "\u{1F3C0}", "\u{1F3C8}", "\u26BE", "\u{1F94E}", "\u{1F3BE}", "\u{1F3D0}", "\u{1F3C9}", "\u{1F94F}", "\u{1F3B1}", "\u{1FA80}", "\u{1F3D3}", "\u{1F3F8}", "\u{1F3D2}", "\u{1F3D1}", "\u{1F94D}", "\u{1F3CF}", "\u{1FA83}", "\u{1F945}", "\u26F3", "\u{1FA81}", "\u{1F3F9}", "\u{1F3A3}", "\u{1F93F}", "\u{1F94A}", "\u{1F94B}", "\u{1F3BD}", "\u{1F6F9}", "\u{1F6FC}", "\u{1F6F7}", "\u26F8\uFE0F", "\u{1F94C}", "\u{1F3BF}", "\u26F7\uFE0F", "\u{1F3C2}", "\u{1FA82}", "\u{1F3CB}\uFE0F", "\u{1F3CB}\uFE0F\u200D\u2642\uFE0F", "\u{1F3CB}\uFE0F\u200D\u2640\uFE0F", "\u{1F93C}", "\u{1F93C}\u200D\u2642\uFE0F", "\u{1F93C}\u200D\u2640\uFE0F", "\u{1F938}", "\u{1F938}\u200D\u2642\uFE0F", "\u{1F938}\u200D\u2640\uFE0F", "\u26F9\uFE0F", "\u26F9\uFE0F\u200D\u2642\uFE0F", "\u26F9\uFE0F\u200D\u2640\uFE0F", "\u{1F93A}", "\u{1F93E}", "\u{1F93E}\u200D\u2642\uFE0F", "\u{1F93E}\u200D\u2640\uFE0F", "\u{1F3CC}\uFE0F", "\u{1F3CC}\uFE0F\u200D\u2642\uFE0F", "\u{1F3CC}\uFE0F\u200D\u2640\uFE0F", "\u{1F3C7}", "\u{1F9D8}", "\u{1F9D8}\u200D\u2642\uFE0F", "\u{1F9D8}\u200D\u2640\uFE0F", "\u{1F3C4}", "\u{1F3C4}\u200D\u2642\uFE0F", "\u{1F3C4}\u200D\u2640\uFE0F", "\u{1F3CA}", "\u{1F3CA}\u200D\u2642\uFE0F", "\u{1F3CA}\u200D\u2640\uFE0F", "\u{1F93D}", "\u{1F93D}\u200D\u2642\uFE0F", "\u{1F93D}\u200D\u2640\uFE0F", "\u{1F6A3}", "\u{1F6A3}\u200D\u2642\uFE0F", "\u{1F6A3}\u200D\u2640\uFE0F", "\u{1F9D7}", "\u{1F9D7}\u200D\u2642\uFE0F", "\u{1F9D7}\u200D\u2640\uFE0F", "\u{1F6B5}", "\u{1F6B5}\u200D\u2642\uFE0F", "\u{1F6B5}\u200D\u2640\uFE0F", "\u{1F6B4}", "\u{1F6B4}\u200D\u2642\uFE0F", "\u{1F6B4}\u200D\u2640\uFE0F", "\u{1F3C6}", "\u{1F947}", "\u{1F948}", "\u{1F949}", "\u{1F3C5}", "\u{1F396}\uFE0F", "\u{1F3F5}\uFE0F", "\u{1F397}\uFE0F", "\u{1F3AB}", "\u{1F39F}\uFE0F", "\u{1F3AA}", "\u{1F939}", "\u{1F939}\u200D\u2642\uFE0F", "\u{1F939}\u200D\u2640\uFE0F", "\u{1F3AD}", "\u{1FA70}", "\u{1F3A8}", "\u{1F3AC}", "\u{1F3A4}", "\u{1F3A7}", "\u{1F3BC}", "\u{1F3B9}", "\u{1F941}", "\u{1FA98}", "\u{1F3B7}", "\u{1F3BA}", "\u{1FA97}", "\u{1F3B8}", "\u{1FA95}", "\u{1F3BB}", "\u{1F3B2}", "\u265F\uFE0F", "\u{1F3AF}", "\u{1F3B3}", "\u{1F3AE}", "\u{1F3B0}", "\u{1F9E9}"],
  "\u{1F697} Travel & Places": ["\u{1F697}", "\u{1F695}", "\u{1F699}", "\u{1F68C}", "\u{1F68E}", "\u{1F3CE}\uFE0F", "\u{1F693}", "\u{1F691}", "\u{1F692}", "\u{1F690}", "\u{1F6FB}", "\u{1F69A}", "\u{1F69B}", "\u{1F69C}", "\u{1F9AF}", "\u{1F9BD}", "\u{1F9BC}", "\u{1F6F4}", "\u{1F6B2}", "\u{1F6F5}", "\u{1F3CD}\uFE0F", "\u{1F6FA}", "\u{1F6A8}", "\u{1F694}", "\u{1F68D}", "\u{1F698}", "\u{1F696}", "\u{1F6A1}", "\u{1F6A0}", "\u{1F69F}", "\u{1F683}", "\u{1F68B}", "\u{1F69E}", "\u{1F69D}", "\u{1F684}", "\u{1F685}", "\u{1F688}", "\u{1F682}", "\u{1F686}", "\u{1F687}", "\u{1F68A}", "\u{1F689}", "\u2708\uFE0F", "\u{1F6EB}", "\u{1F6EC}", "\u{1F6E9}\uFE0F", "\u{1F4BA}", "\u{1F6F0}\uFE0F", "\u{1F680}", "\u{1F6F8}", "\u{1F681}", "\u{1F6F6}", "\u26F5", "\u{1F6A4}", "\u{1F6E5}\uFE0F", "\u{1F6F3}\uFE0F", "\u26F4\uFE0F", "\u{1F6A2}", "\u2693", "\u26FD", "\u{1F6A7}", "\u{1F6A6}", "\u{1F6A5}", "\u{1F68F}", "\u{1F5FA}\uFE0F", "\u{1F5FF}", "\u{1F5FD}", "\u{1F5FC}", "\u{1F3F0}", "\u{1F3EF}", "\u{1F3DF}\uFE0F", "\u{1F3A1}", "\u{1F3A2}", "\u{1F3A0}", "\u26F2", "\u26F1\uFE0F", "\u{1F3D6}\uFE0F", "\u{1F3DD}\uFE0F", "\u{1F3DC}\uFE0F", "\u{1F30B}", "\u26F0\uFE0F", "\u{1F3D4}\uFE0F", "\u{1F5FB}", "\u{1F3D5}\uFE0F", "\u26FA", "\u{1F6D6}", "\u{1F3E0}", "\u{1F3E1}", "\u{1F3D8}\uFE0F", "\u{1F3DA}\uFE0F", "\u{1F3D7}\uFE0F", "\u{1F3ED}", "\u{1F3E2}", "\u{1F3EC}", "\u{1F3E3}", "\u{1F3E4}", "\u{1F3E5}", "\u{1F3E6}", "\u{1F3E8}", "\u{1F3EA}", "\u{1F3EB}", "\u{1F3E9}", "\u{1F492}", "\u{1F3DB}\uFE0F", "\u26EA", "\u{1F54C}", "\u{1F54D}", "\u{1F6D5}", "\u{1F54B}", "\u26E9\uFE0F", "\u{1F6E4}\uFE0F", "\u{1F6E3}\uFE0F", "\u{1F5FE}", "\u{1F391}", "\u{1F3DE}\uFE0F", "\u{1F305}", "\u{1F304}", "\u{1F320}", "\u{1F387}", "\u{1F386}", "\u{1F307}", "\u{1F306}", "\u{1F3D9}\uFE0F", "\u{1F303}", "\u{1F30C}", "\u{1F309}", "\u{1F301}"],
  "\u{1F4BB} Objects & Technology": ["\u231A", "\u{1F4F1}", "\u{1F4F2}", "\u{1F4BB}", "\u2328\uFE0F", "\u{1F5A5}\uFE0F", "\u{1F5A8}\uFE0F", "\u{1F5B1}\uFE0F", "\u{1F5B2}\uFE0F", "\u{1F579}\uFE0F", "\u{1F5DC}\uFE0F", "\u{1F4BE}", "\u{1F4BF}", "\u{1F4C0}", "\u{1F4FC}", "\u{1F4F7}", "\u{1F4F8}", "\u{1F4F9}", "\u{1F3A5}", "\u{1F4FD}\uFE0F", "\u{1F39E}\uFE0F", "\u{1F4DE}", "\u260E\uFE0F", "\u{1F4DF}", "\u{1F4E0}", "\u{1F4FA}", "\u{1F4FB}", "\u{1F399}\uFE0F", "\u{1F39A}\uFE0F", "\u{1F39B}\uFE0F", "\u{1F9ED}", "\u23F1\uFE0F", "\u23F2\uFE0F", "\u23F0", "\u{1F570}\uFE0F", "\u231B", "\u23F3", "\u{1F4E1}", "\u{1F50B}", "\u{1F50C}", "\u{1F4A1}", "\u{1F526}", "\u{1F56F}\uFE0F", "\u{1FA94}", "\u{1F9EF}", "\u{1F6E2}\uFE0F", "\u{1F4B8}", "\u{1F4B5}", "\u{1F4B4}", "\u{1F4B6}", "\u{1F4B7}", "\u{1FA99}", "\u{1F4B0}", "\u{1F4B3}", "\u{1F48E}", "\u2696\uFE0F", "\u{1FA9C}", "\u{1F9F0}", "\u{1FA9B}", "\u{1F527}", "\u{1F528}", "\u2692\uFE0F", "\u{1F6E0}\uFE0F", "\u26CF\uFE0F", "\u{1FA9A}", "\u{1F529}", "\u2699\uFE0F", "\u{1FAA4}", "\u{1F9F1}", "\u26D3\uFE0F", "\u{1F9F2}", "\u{1F52B}", "\u{1F4A3}", "\u{1F9E8}", "\u{1FA93}", "\u{1F52A}", "\u{1F5E1}\uFE0F", "\u2694\uFE0F", "\u{1F6E1}\uFE0F", "\u{1F6AC}", "\u26B0\uFE0F", "\u{1FAA6}", "\u26B1\uFE0F", "\u{1F3FA}", "\u{1F52E}", "\u{1F4FF}", "\u{1F9FF}", "\u{1F488}", "\u2697\uFE0F", "\u{1F52D}", "\u{1F52C}", "\u{1F573}\uFE0F", "\u{1FA79}", "\u{1FA7A}", "\u{1F48A}", "\u{1F489}", "\u{1FA78}", "\u{1F9EC}", "\u{1F9B7}", "\u{1F9EA}", "\u{1F321}\uFE0F", "\u{1F9F9}", "\u{1FAA0}", "\u{1F9FA}", "\u{1F9FB}", "\u{1F6BD}", "\u{1F6B0}", "\u{1F6BF}", "\u{1F6C1}", "\u{1F6C0}", "\u{1F9FC}", "\u{1FAA5}", "\u{1FA92}", "\u{1F9FD}", "\u{1FAA3}", "\u{1F9F4}", "\u{1F6CE}\uFE0F", "\u{1F511}", "\u{1F5DD}\uFE0F", "\u{1F6AA}", "\u{1FA91}", "\u{1F6CB}\uFE0F", "\u{1F6CF}\uFE0F", "\u{1F6CC}", "\u{1F9F8}", "\u{1FA86}", "\u{1F5BC}\uFE0F", "\u{1FA9E}", "\u{1FA9F}", "\u{1F6CD}\uFE0F", "\u{1F6D2}", "\u{1F381}", "\u{1F388}", "\u{1F38F}", "\u{1F380}", "\u{1FA84}", "\u{1FA85}", "\u{1F38A}", "\u{1F389}", "\u{1F38E}", "\u{1F3EE}", "\u{1F390}", "\u{1F9E7}"],
  "\u{1F4CB} Office & Writing": ["\u2709\uFE0F", "\u{1F4E7}", "\u{1F4E8}", "\u{1F4E9}", "\u{1F4E4}", "\u{1F4E5}", "\u{1F4E6}", "\u{1F4EB}", "\u{1F4EA}", "\u{1F4EC}", "\u{1F4ED}", "\u{1F4EE}", "\u{1F5F3}\uFE0F", "\u270F\uFE0F", "\u2712\uFE0F", "\u{1F58B}\uFE0F", "\u{1F58A}\uFE0F", "\u{1F58C}\uFE0F", "\u{1F58D}\uFE0F", "\u{1F4DD}", "\u{1F4BC}", "\u{1F4C1}", "\u{1F4C2}", "\u{1F5C2}\uFE0F", "\u{1F4C5}", "\u{1F4C6}", "\u{1F5D2}\uFE0F", "\u{1F5D3}\uFE0F", "\u{1F4C7}", "\u{1F4C8}", "\u{1F4C9}", "\u{1F4CA}", "\u{1F4CB}", "\u{1F4CC}", "\u{1F4CD}", "\u{1F4CE}", "\u{1F587}\uFE0F", "\u{1F4CF}", "\u{1F4D0}", "\u2702\uFE0F", "\u{1F5C3}\uFE0F", "\u{1F5C4}\uFE0F", "\u{1F5D1}\uFE0F", "\u{1F512}", "\u{1F513}", "\u{1F50F}", "\u{1F510}", "\u{1F511}", "\u{1F5DD}\uFE0F", "\u{1F528}", "\u{1FA93}", "\u26CF\uFE0F", "\u2692\uFE0F", "\u{1F6E0}\uFE0F", "\u{1F5E1}\uFE0F", "\u2694\uFE0F", "\u{1F4A3}", "\u{1FA83}", "\u{1F3F9}", "\u{1F6E1}\uFE0F", "\u{1FA9A}", "\u{1F527}", "\u{1FA9B}", "\u{1F529}", "\u2699\uFE0F", "\u{1F5DC}\uFE0F", "\u2696\uFE0F"],
  "\u{1F3B5} Music & Sound": ["\u{1F3B5}", "\u{1F3B6}", "\u{1F3BC}", "\u{1F3B9}", "\u{1F3B8}", "\u{1F3BA}", "\u{1F3B7}", "\u{1F941}", "\u{1FA98}", "\u{1F3A4}", "\u{1F3A7}", "\u{1F4FB}", "\u{1F399}\uFE0F", "\u{1F50A}", "\u{1F509}", "\u{1F508}", "\u{1F507}", "\u{1F4E2}", "\u{1F4E3}", "\u{1F4EF}", "\u{1F514}", "\u{1F515}", "\u{1F39A}\uFE0F", "\u{1F39B}\uFE0F", "\u{1F396}\uFE0F", "\u{1F3C6}", "\u{1F947}", "\u{1F948}", "\u{1F949}", "\u26A1", "\u{1F525}", "\u{1F4A5}"],
  "\u26A1 Symbols & Signs": ["\u2764\uFE0F", "\u{1F9E1}", "\u{1F49B}", "\u{1F49A}", "\u{1F499}", "\u{1F49C}", "\u{1F5A4}", "\u{1F90D}", "\u{1F90E}", "\u{1F494}", "\u2763\uFE0F", "\u{1F495}", "\u{1F49E}", "\u{1F493}", "\u{1F497}", "\u{1F496}", "\u{1F498}", "\u{1F49D}", "\u{1F49F}", "\u262E\uFE0F", "\u271D\uFE0F", "\u262A\uFE0F", "\u{1F549}\uFE0F", "\u2638\uFE0F", "\u2721\uFE0F", "\u{1F52F}", "\u{1F54E}", "\u262F\uFE0F", "\u2626\uFE0F", "\u{1F6D0}", "\u26CE", "\u2648", "\u2649", "\u264A", "\u264B", "\u264C", "\u264D", "\u264E", "\u264F", "\u2650", "\u2651", "\u2652", "\u2653", "\u{1F194}", "\u269B\uFE0F", "\u{1F251}", "\u2622\uFE0F", "\u2623\uFE0F", "\u{1F4F4}", "\u{1F4F3}", "\u{1F236}", "\u{1F21A}", "\u{1F238}", "\u{1F23A}", "\u{1F237}\uFE0F", "\u2734\uFE0F", "\u{1F19A}", "\u{1F4AE}", "\u{1F250}", "\u3299\uFE0F", "\u3297\uFE0F", "\u{1F234}", "\u{1F235}", "\u{1F239}", "\u{1F232}", "\u{1F170}\uFE0F", "\u{1F171}\uFE0F", "\u{1F18E}", "\u{1F191}", "\u{1F17E}\uFE0F", "\u{1F198}", "\u274C", "\u2B55", "\u{1F6D1}", "\u26D4", "\u{1F4DB}", "\u{1F6AB}", "\u{1F4AF}", "\u{1F4A2}", "\u2668\uFE0F", "\u{1F6B7}", "\u{1F6AF}", "\u{1F6B3}", "\u{1F6B1}", "\u{1F51E}", "\u{1F4F5}", "\u{1F6AD}", "\u2757", "\u2755", "\u2753", "\u2754", "\u203C\uFE0F", "\u2049\uFE0F", "\u{1F505}", "\u{1F506}", "\u303D\uFE0F", "\u26A0\uFE0F", "\u{1F6B8}", "\u{1F531}", "\u269C\uFE0F", "\u{1F530}", "\u267B\uFE0F", "\u2705", "\u{1F22F}", "\u{1F4B9}", "\u2747\uFE0F", "\u2733\uFE0F", "\u274E", "\u{1F310}", "\u{1F4A0}", "\u24C2\uFE0F", "\u{1F300}", "\u{1F4A4}", "\u{1F3E7}", "\u{1F6BE}", "\u267F", "\u{1F17F}\uFE0F", "\u{1F6D7}", "\u{1F233}", "\u{1F202}\uFE0F", "\u{1F6C2}", "\u{1F6C3}", "\u{1F6C4}", "\u{1F6C5}", "\u{1F6B9}", "\u{1F6BA}", "\u{1F6BC}", "\u26A7\uFE0F", "\u{1F6BB}", "\u{1F6AE}", "\u{1F3A6}", "\u{1F4F6}", "\u{1F201}", "\u{1F523}", "\u2139\uFE0F", "\u{1F524}", "\u{1F521}", "\u{1F520}", "\u{1F196}", "\u{1F197}", "\u{1F199}", "\u{1F192}", "\u{1F195}", "\u{1F193}", "0\uFE0F\u20E3", "1\uFE0F\u20E3", "2\uFE0F\u20E3", "3\uFE0F\u20E3", "4\uFE0F\u20E3", "5\uFE0F\u20E3", "6\uFE0F\u20E3", "7\uFE0F\u20E3", "8\uFE0F\u20E3", "9\uFE0F\u20E3", "\u{1F51F}", "\u{1F522}", "#\uFE0F\u20E3", "*\uFE0F\u20E3", "\u23CF\uFE0F", "\u25B6\uFE0F", "\u23F8\uFE0F", "\u23EF\uFE0F", "\u23F9\uFE0F", "\u23FA\uFE0F", "\u23ED\uFE0F", "\u23EE\uFE0F", "\u23E9", "\u23EA", "\u23EB", "\u23EC", "\u25C0\uFE0F", "\u{1F53C}", "\u{1F53D}", "\u27A1\uFE0F", "\u2B05\uFE0F", "\u2B06\uFE0F", "\u2B07\uFE0F", "\u2197\uFE0F", "\u2198\uFE0F", "\u2199\uFE0F", "\u2196\uFE0F", "\u2195\uFE0F", "\u2194\uFE0F", "\u21AA\uFE0F", "\u21A9\uFE0F", "\u2934\uFE0F", "\u2935\uFE0F", "\u{1F500}", "\u{1F501}", "\u{1F502}", "\u{1F504}", "\u{1F503}", "\u{1F3B5}", "\u{1F3B6}", "\u2795", "\u2796", "\u2797", "\u2716\uFE0F", "\u267E\uFE0F", "\u{1F4B2}", "\u{1F4B1}", "\u2122\uFE0F", "\xA9\uFE0F", "\xAE\uFE0F", "\u3030\uFE0F", "\u27B0", "\u27BF", "\u{1F51A}", "\u{1F519}", "\u{1F51B}", "\u{1F51D}", "\u{1F51C}", "\u2714\uFE0F", "\u2611\uFE0F", "\u{1F518}", "\u{1F534}", "\u{1F7E0}", "\u{1F7E1}", "\u{1F7E2}", "\u{1F535}", "\u{1F7E3}", "\u26AB", "\u26AA", "\u{1F7E4}", "\u{1F53A}", "\u{1F53B}", "\u{1F538}", "\u{1F539}", "\u{1F536}", "\u{1F537}", "\u{1F533}", "\u{1F532}", "\u25AA\uFE0F", "\u25AB\uFE0F", "\u25FE", "\u25FD", "\u25FC\uFE0F", "\u25FB\uFE0F", "\u{1F7E5}", "\u{1F7E7}", "\u{1F7E8}", "\u{1F7E9}", "\u{1F7E6}", "\u{1F7EA}", "\u2B1B", "\u2B1C", "\u{1F7EB}", "\u{1F508}", "\u{1F507}", "\u{1F509}", "\u{1F50A}", "\u{1F514}", "\u{1F515}", "\u{1F4E3}", "\u{1F4E2}", "\u{1F4AC}", "\u{1F4AD}", "\u{1F5EF}\uFE0F", "\u2660\uFE0F", "\u2663\uFE0F", "\u2665\uFE0F", "\u2666\uFE0F", "\u{1F0CF}", "\u{1F3B4}", "\u{1F004}", "\u{1F550}", "\u{1F551}", "\u{1F552}", "\u{1F553}", "\u{1F554}", "\u{1F555}", "\u{1F556}", "\u{1F557}", "\u{1F558}", "\u{1F559}", "\u{1F55A}", "\u{1F55B}", "\u{1F55C}", "\u{1F55D}", "\u{1F55E}", "\u{1F55F}", "\u{1F560}", "\u{1F561}", "\u{1F562}", "\u{1F563}", "\u{1F564}", "\u{1F565}", "\u{1F566}", "\u{1F567}"],
  "\u{1F3C1} Flags": ["\u{1F3C1}", "\u{1F6A9}", "\u{1F38C}", "\u{1F3F4}", "\u{1F3F3}\uFE0F", "\u{1F3F3}\uFE0F\u200D\u{1F308}", "\u{1F3F3}\uFE0F\u200D\u26A7\uFE0F", "\u{1F3F4}\u200D\u2620\uFE0F", "\u{1F1E6}\u{1F1E8}", "\u{1F1E6}\u{1F1E9}", "\u{1F1E6}\u{1F1EA}", "\u{1F1E6}\u{1F1EB}", "\u{1F1E6}\u{1F1EC}", "\u{1F1E6}\u{1F1EE}", "\u{1F1E6}\u{1F1F1}", "\u{1F1E6}\u{1F1F2}", "\u{1F1E6}\u{1F1F4}", "\u{1F1E6}\u{1F1F6}", "\u{1F1E6}\u{1F1F7}", "\u{1F1E6}\u{1F1F8}", "\u{1F1E6}\u{1F1F9}", "\u{1F1E6}\u{1F1FA}", "\u{1F1E6}\u{1F1FC}", "\u{1F1E6}\u{1F1FD}", "\u{1F1E6}\u{1F1FF}", "\u{1F1E7}\u{1F1E6}", "\u{1F1E7}\u{1F1E7}", "\u{1F1E7}\u{1F1E9}", "\u{1F1E7}\u{1F1EA}", "\u{1F1E7}\u{1F1EB}", "\u{1F1E7}\u{1F1EC}", "\u{1F1E7}\u{1F1ED}", "\u{1F1E7}\u{1F1EE}", "\u{1F1E7}\u{1F1EF}", "\u{1F1E7}\u{1F1F1}", "\u{1F1E7}\u{1F1F2}", "\u{1F1E7}\u{1F1F3}", "\u{1F1E7}\u{1F1F4}", "\u{1F1E7}\u{1F1F6}", "\u{1F1E7}\u{1F1F7}", "\u{1F1E7}\u{1F1F8}", "\u{1F1E7}\u{1F1F9}", "\u{1F1E7}\u{1F1FB}", "\u{1F1E7}\u{1F1FC}", "\u{1F1E7}\u{1F1FE}", "\u{1F1E7}\u{1F1FF}", "\u{1F1E8}\u{1F1E6}", "\u{1F1E8}\u{1F1E8}", "\u{1F1E8}\u{1F1E9}", "\u{1F1E8}\u{1F1EB}", "\u{1F1E8}\u{1F1EC}", "\u{1F1E8}\u{1F1ED}", "\u{1F1E8}\u{1F1EE}", "\u{1F1E8}\u{1F1F0}", "\u{1F1E8}\u{1F1F1}", "\u{1F1E8}\u{1F1F2}", "\u{1F1E8}\u{1F1F3}", "\u{1F1E8}\u{1F1F4}", "\u{1F1E8}\u{1F1F5}", "\u{1F1E8}\u{1F1F7}", "\u{1F1E8}\u{1F1FA}", "\u{1F1E8}\u{1F1FB}", "\u{1F1E8}\u{1F1FC}", "\u{1F1E8}\u{1F1FD}", "\u{1F1E8}\u{1F1FE}", "\u{1F1E8}\u{1F1FF}", "\u{1F1E9}\u{1F1EA}", "\u{1F1E9}\u{1F1EC}", "\u{1F1E9}\u{1F1EF}", "\u{1F1E9}\u{1F1F0}", "\u{1F1E9}\u{1F1F2}", "\u{1F1E9}\u{1F1F4}", "\u{1F1E9}\u{1F1FF}", "\u{1F1EA}\u{1F1E6}", "\u{1F1EA}\u{1F1E8}", "\u{1F1EA}\u{1F1EA}", "\u{1F1EA}\u{1F1EC}", "\u{1F1EA}\u{1F1ED}", "\u{1F1EA}\u{1F1F7}", "\u{1F1EA}\u{1F1F8}", "\u{1F1EA}\u{1F1F9}", "\u{1F1EA}\u{1F1FA}", "\u{1F1EB}\u{1F1EE}", "\u{1F1EB}\u{1F1EF}", "\u{1F1EB}\u{1F1F0}", "\u{1F1EB}\u{1F1F2}", "\u{1F1EB}\u{1F1F4}", "\u{1F1EB}\u{1F1F7}", "\u{1F1EC}\u{1F1E6}", "\u{1F1EC}\u{1F1E7}", "\u{1F1EC}\u{1F1E9}", "\u{1F1EC}\u{1F1EA}", "\u{1F1EC}\u{1F1EB}", "\u{1F1EC}\u{1F1EC}", "\u{1F1EC}\u{1F1ED}", "\u{1F1EC}\u{1F1EE}", "\u{1F1EC}\u{1F1F1}", "\u{1F1EC}\u{1F1F2}", "\u{1F1EC}\u{1F1F3}", "\u{1F1EC}\u{1F1F5}", "\u{1F1EC}\u{1F1F6}", "\u{1F1EC}\u{1F1F7}", "\u{1F1EC}\u{1F1F8}", "\u{1F1EC}\u{1F1F9}", "\u{1F1EC}\u{1F1FA}", "\u{1F1EC}\u{1F1FC}", "\u{1F1EC}\u{1F1FE}", "\u{1F1ED}\u{1F1F0}", "\u{1F1ED}\u{1F1F2}", "\u{1F1ED}\u{1F1F3}", "\u{1F1ED}\u{1F1F7}", "\u{1F1ED}\u{1F1F9}", "\u{1F1ED}\u{1F1FA}", "\u{1F1EE}\u{1F1E8}", "\u{1F1EE}\u{1F1E9}", "\u{1F1EE}\u{1F1EA}", "\u{1F1EE}\u{1F1F1}", "\u{1F1EE}\u{1F1F2}", "\u{1F1EE}\u{1F1F3}", "\u{1F1EE}\u{1F1F4}", "\u{1F1EE}\u{1F1F6}", "\u{1F1EE}\u{1F1F7}", "\u{1F1EE}\u{1F1F8}", "\u{1F1EE}\u{1F1F9}", "\u{1F1EF}\u{1F1EA}", "\u{1F1EF}\u{1F1F2}", "\u{1F1EF}\u{1F1F4}", "\u{1F1EF}\u{1F1F5}", "\u{1F1F0}\u{1F1EA}", "\u{1F1F0}\u{1F1EC}", "\u{1F1F0}\u{1F1ED}", "\u{1F1F0}\u{1F1EE}", "\u{1F1F0}\u{1F1F2}", "\u{1F1F0}\u{1F1F3}", "\u{1F1F0}\u{1F1F5}", "\u{1F1F0}\u{1F1F7}", "\u{1F1F0}\u{1F1FC}", "\u{1F1F0}\u{1F1FE}", "\u{1F1F0}\u{1F1FF}", "\u{1F1F1}\u{1F1E6}", "\u{1F1F1}\u{1F1E7}", "\u{1F1F1}\u{1F1E8}", "\u{1F1F1}\u{1F1EE}", "\u{1F1F1}\u{1F1F0}", "\u{1F1F1}\u{1F1F7}", "\u{1F1F1}\u{1F1F8}", "\u{1F1F1}\u{1F1F9}", "\u{1F1F1}\u{1F1FA}", "\u{1F1F1}\u{1F1FB}", "\u{1F1F1}\u{1F1FE}", "\u{1F1F2}\u{1F1E6}", "\u{1F1F2}\u{1F1E8}", "\u{1F1F2}\u{1F1E9}", "\u{1F1F2}\u{1F1EA}", "\u{1F1F2}\u{1F1EB}", "\u{1F1F2}\u{1F1EC}", "\u{1F1F2}\u{1F1ED}", "\u{1F1F2}\u{1F1F0}", "\u{1F1F2}\u{1F1F1}", "\u{1F1F2}\u{1F1F2}", "\u{1F1F2}\u{1F1F3}", "\u{1F1F2}\u{1F1F4}", "\u{1F1F2}\u{1F1F5}", "\u{1F1F2}\u{1F1F6}", "\u{1F1F2}\u{1F1F7}", "\u{1F1F2}\u{1F1F8}", "\u{1F1F2}\u{1F1F9}", "\u{1F1F2}\u{1F1FA}", "\u{1F1F2}\u{1F1FB}", "\u{1F1F2}\u{1F1FC}", "\u{1F1F2}\u{1F1FD}", "\u{1F1F2}\u{1F1FE}", "\u{1F1F2}\u{1F1FF}", "\u{1F1F3}\u{1F1E6}", "\u{1F1F3}\u{1F1E8}", "\u{1F1F3}\u{1F1EA}", "\u{1F1F3}\u{1F1EB}", "\u{1F1F3}\u{1F1EC}", "\u{1F1F3}\u{1F1EE}", "\u{1F1F3}\u{1F1F1}", "\u{1F1F3}\u{1F1F4}", "\u{1F1F3}\u{1F1F5}", "\u{1F1F3}\u{1F1F7}", "\u{1F1F3}\u{1F1FA}", "\u{1F1F3}\u{1F1FF}", "\u{1F1F4}\u{1F1F2}", "\u{1F1F5}\u{1F1E6}", "\u{1F1F5}\u{1F1EA}", "\u{1F1F5}\u{1F1EB}", "\u{1F1F5}\u{1F1EC}", "\u{1F1F5}\u{1F1ED}", "\u{1F1F5}\u{1F1F0}", "\u{1F1F5}\u{1F1F1}", "\u{1F1F5}\u{1F1F2}", "\u{1F1F5}\u{1F1F3}", "\u{1F1F5}\u{1F1F7}", "\u{1F1F5}\u{1F1F8}", "\u{1F1F5}\u{1F1F9}", "\u{1F1F5}\u{1F1FC}", "\u{1F1F5}\u{1F1FE}", "\u{1F1F6}\u{1F1E6}", "\u{1F1F7}\u{1F1EA}", "\u{1F1F7}\u{1F1F4}", "\u{1F1F7}\u{1F1F8}", "\u{1F1F7}\u{1F1FA}", "\u{1F1F7}\u{1F1FC}", "\u{1F1F8}\u{1F1E6}", "\u{1F1F8}\u{1F1E7}", "\u{1F1F8}\u{1F1E8}", "\u{1F1F8}\u{1F1E9}", "\u{1F1F8}\u{1F1EA}", "\u{1F1F8}\u{1F1EC}", "\u{1F1F8}\u{1F1ED}", "\u{1F1F8}\u{1F1EE}", "\u{1F1F8}\u{1F1EF}", "\u{1F1F8}\u{1F1F0}", "\u{1F1F8}\u{1F1F1}", "\u{1F1F8}\u{1F1F2}", "\u{1F1F8}\u{1F1F3}", "\u{1F1F8}\u{1F1F4}", "\u{1F1F8}\u{1F1F7}", "\u{1F1F8}\u{1F1F8}", "\u{1F1F8}\u{1F1F9}", "\u{1F1F8}\u{1F1FB}", "\u{1F1F8}\u{1F1FD}", "\u{1F1F8}\u{1F1FE}", "\u{1F1F8}\u{1F1FF}", "\u{1F1F9}\u{1F1E6}", "\u{1F1F9}\u{1F1E8}", "\u{1F1F9}\u{1F1E9}", "\u{1F1F9}\u{1F1EB}", "\u{1F1F9}\u{1F1EC}", "\u{1F1F9}\u{1F1ED}", "\u{1F1F9}\u{1F1EF}", "\u{1F1F9}\u{1F1F0}", "\u{1F1F9}\u{1F1F1}", "\u{1F1F9}\u{1F1F2}", "\u{1F1F9}\u{1F1F3}", "\u{1F1F9}\u{1F1F4}", "\u{1F1F9}\u{1F1F7}", "\u{1F1F9}\u{1F1F9}", "\u{1F1F9}\u{1F1FB}", "\u{1F1F9}\u{1F1FC}", "\u{1F1F9}\u{1F1FF}", "\u{1F1FA}\u{1F1E6}", "\u{1F1FA}\u{1F1EC}", "\u{1F1FA}\u{1F1F2}", "\u{1F1FA}\u{1F1F3}", "\u{1F1FA}\u{1F1F8}", "\u{1F1FA}\u{1F1FE}", "\u{1F1FA}\u{1F1FF}", "\u{1F1FB}\u{1F1E6}", "\u{1F1FB}\u{1F1E8}", "\u{1F1FB}\u{1F1EA}", "\u{1F1FB}\u{1F1EC}", "\u{1F1FB}\u{1F1EE}", "\u{1F1FB}\u{1F1F3}", "\u{1F1FB}\u{1F1FA}", "\u{1F1FC}\u{1F1EB}", "\u{1F1FC}\u{1F1F8}", "\u{1F1FD}\u{1F1F0}", "\u{1F1FE}\u{1F1EA}", "\u{1F1FE}\u{1F1F9}", "\u{1F1FF}\u{1F1E6}", "\u{1F1FF}\u{1F1F2}", "\u{1F1FF}\u{1F1FC}", "\u{1F3F4}\u{E0067}\u{E0062}\u{E0065}\u{E006E}\u{E0067}\u{E007F}", "\u{1F3F4}\u{E0067}\u{E0062}\u{E0073}\u{E0063}\u{E0074}\u{E007F}", "\u{1F3F4}\u{E0067}\u{E0062}\u{E0077}\u{E006C}\u{E0073}\u{E007F}"]
};
var QuickAddTaskModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.taskText = "";
    this.selectedList = "work";
    this.scheduledDate = "";
    this.scheduledTime = "";
    this.reminderMinutes = 0;
    this.plugin = plugin;
    this.estimatedMinutes = plugin.settings.defaultEstimateMinutes;
    this.reminderMinutes = plugin.settings.defaultReminderMinutes;
    if (plugin.settings.lists.length > 0) {
      this.selectedList = plugin.settings.lists[0].id;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("immerse-modal");
    contentEl.createEl("h2", { text: "\u26A1 Add New Task" });
    new import_obsidian.Setting(contentEl).setName("Task").addText((text) => {
      text.setPlaceholder("What do you need to do?").onChange((value) => this.taskText = value);
      text.inputEl.focus();
      text.inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && this.taskText.trim()) {
          this.submitTask();
        }
      });
    });
    new import_obsidian.Setting(contentEl).setName("Estimated Time").setDesc("How long do you think this will take?").addDropdown((dropdown) => {
      const options = {
        "5": "5 min",
        "10": "10 min",
        "15": "15 min",
        "20": "20 min",
        "25": "25 min (1 pomodoro)",
        "30": "30 min",
        "45": "45 min",
        "50": "50 min (2 pomodoros)",
        "60": "1 hour",
        "90": "1.5 hours",
        "120": "2 hours",
        "180": "3 hours"
      };
      Object.entries(options).forEach(([value, label]) => {
        dropdown.addOption(value, label);
      });
      dropdown.setValue(this.estimatedMinutes.toString());
      dropdown.onChange((value) => this.estimatedMinutes = parseInt(value));
    });
    new import_obsidian.Setting(contentEl).setName("List").addDropdown((dropdown) => {
      this.plugin.settings.lists.forEach((list) => {
        dropdown.addOption(list.id, `${list.icon} ${list.name}`);
      });
      dropdown.setValue(this.selectedList);
      dropdown.onChange((value) => this.selectedList = value);
    });
    new import_obsidian.Setting(contentEl).setName("\u{1F4C5} Scheduled Date").setDesc("Optional: When do you plan to work on this?").addText((text) => {
      text.setPlaceholder("YYYY-MM-DD").setValue(this.scheduledDate).onChange((value) => this.scheduledDate = value);
      text.inputEl.type = "date";
    });
    new import_obsidian.Setting(contentEl).setName("\u23F0 Scheduled Time").setDesc("Optional: What time?").addText((text) => {
      text.setPlaceholder("HH:mm").setValue(this.scheduledTime).onChange((value) => this.scheduledTime = value);
      text.inputEl.type = "time";
    });
    if (this.plugin.settings.enableReminders) {
      new import_obsidian.Setting(contentEl).setName("\u{1F514} Reminder").setDesc("Remind me before the scheduled time").addDropdown((dropdown) => {
        dropdown.addOption("0", "No reminder");
        dropdown.addOption("5", "5 minutes before");
        dropdown.addOption("10", "10 minutes before");
        dropdown.addOption("15", "15 minutes before");
        dropdown.addOption("30", "30 minutes before");
        dropdown.addOption("60", "1 hour before");
        dropdown.setValue(this.reminderMinutes.toString());
        dropdown.onChange((value) => this.reminderMinutes = parseInt(value));
      });
    }
    const buttonContainer = contentEl.createEl("div", { cls: "immerse-modal-buttons" });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel", cls: "immerse-btn" });
    cancelBtn.addEventListener("click", () => this.close());
    const addBtn = buttonContainer.createEl("button", { text: "Add Task", cls: "immerse-btn immerse-btn-primary" });
    addBtn.addEventListener("click", () => this.submitTask());
  }
  submitTask() {
    if (this.taskText.trim()) {
      const task = this.plugin.createTask(this.taskText, this.estimatedMinutes, this.selectedList);
      if (this.scheduledDate) {
        task.scheduledDate = this.scheduledDate;
      }
      if (this.scheduledTime) {
        task.scheduledTime = this.scheduledTime;
      }
      if (this.reminderMinutes > 0 && this.scheduledDate && this.scheduledTime) {
        task.reminderMinutes = this.reminderMinutes;
      }
      this.plugin.addTask(task);
      new import_obsidian.Notice("\u2705 Task added!");
      this.close();
    } else {
      new import_obsidian.Notice("Please enter a task description");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var EditTaskModal = class extends import_obsidian.Modal {
  constructor(app, plugin, task) {
    super(app);
    this.plugin = plugin;
    this.task = { ...task };
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("immerse-modal");
    contentEl.createEl("h2", { text: "\u270F\uFE0F Edit Task" });
    new import_obsidian.Setting(contentEl).setName("Task").addText((text) => text.setValue(this.task.text).onChange((value) => this.task.text = value));
    new import_obsidian.Setting(contentEl).setName("Estimated Time").addDropdown((dropdown) => {
      const options = {
        "5": "5 min",
        "10": "10 min",
        "15": "15 min",
        "20": "20 min",
        "25": "25 min",
        "30": "30 min",
        "45": "45 min",
        "50": "50 min",
        "60": "1 hour",
        "90": "1.5 hours",
        "120": "2 hours",
        "180": "3 hours"
      };
      Object.entries(options).forEach(([value, label]) => {
        dropdown.addOption(value, label);
      });
      dropdown.setValue(this.task.estimatedMinutes.toString());
      dropdown.onChange((value) => this.task.estimatedMinutes = parseInt(value));
    });
    new import_obsidian.Setting(contentEl).setName("List").addDropdown((dropdown) => {
      this.plugin.settings.lists.forEach((list) => {
        dropdown.addOption(list.id, `${list.icon} ${list.name}`);
      });
      dropdown.setValue(this.task.list);
      dropdown.onChange((value) => this.task.list = value);
    });
    new import_obsidian.Setting(contentEl).setName("Notes").setDesc("Add any additional details or links").addTextArea((textarea) => {
      textarea.setValue(this.task.notes).onChange((value) => this.task.notes = value);
      textarea.inputEl.rows = 4;
    });
    new import_obsidian.Setting(contentEl).setName("\u{1F4C5} Scheduled Date").setDesc("Optional: When do you plan to work on this?").addText((text) => {
      text.setPlaceholder("YYYY-MM-DD").setValue(this.task.scheduledDate || "").onChange((value) => this.task.scheduledDate = value || void 0);
      text.inputEl.type = "date";
    });
    new import_obsidian.Setting(contentEl).setName("\u23F0 Scheduled Time").setDesc("Optional: What time?").addText((text) => {
      text.setPlaceholder("HH:mm").setValue(this.task.scheduledTime || "").onChange((value) => this.task.scheduledTime = value || void 0);
      text.inputEl.type = "time";
    });
    if (this.plugin.settings.enableReminders) {
      new import_obsidian.Setting(contentEl).setName("\u{1F514} Reminder").setDesc("Remind me before the scheduled time").addDropdown((dropdown) => {
        dropdown.addOption("0", "No reminder");
        dropdown.addOption("5", "5 minutes before");
        dropdown.addOption("10", "10 minutes before");
        dropdown.addOption("15", "15 minutes before");
        dropdown.addOption("30", "30 minutes before");
        dropdown.addOption("60", "1 hour before");
        dropdown.setValue((this.task.reminderMinutes || 0).toString());
        dropdown.onChange((value) => {
          const minutes = parseInt(value);
          this.task.reminderMinutes = minutes > 0 ? minutes : void 0;
        });
      });
    }
    if (this.task.actualMinutes > 0) {
      new import_obsidian.Setting(contentEl).setName("Time Tracked").setDesc(`You've worked on this task for ${this.plugin.formatTimeHuman(this.task.actualMinutes)}`);
    }
    const buttonContainer = contentEl.createEl("div", { cls: "immerse-modal-buttons" });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel", cls: "immerse-btn" });
    cancelBtn.addEventListener("click", () => this.close());
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "immerse-btn immerse-btn-primary" });
    saveBtn.addEventListener("click", () => {
      this.plugin.updateTask(this.task.id, this.task);
      new import_obsidian.Notice("\u2705 Task updated!");
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var EmojiPickerModal = class extends import_obsidian.Modal {
  constructor(app, currentEmoji, onSelect) {
    super(app);
    this.currentEmoji = currentEmoji;
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("immerse-emoji-picker");
    contentEl.createEl("h2", { text: "Select Emoji" });
    if (this.currentEmoji) {
      const currentDiv = contentEl.createDiv({ cls: "immerse-emoji-current" });
      currentDiv.createEl("span", { text: "Current: " });
      currentDiv.createEl("span", { text: this.currentEmoji, cls: "immerse-emoji-current-icon" });
    }
    const searchContainer = contentEl.createDiv({ cls: "immerse-emoji-search" });
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search emojis...",
      cls: "immerse-emoji-search-input"
    });
    const gridContainer = contentEl.createDiv({ cls: "immerse-emoji-categories" });
    const renderCategories = (filter = "") => {
      gridContainer.empty();
      Object.entries(EMOJI_CATEGORIES).forEach(([category, emojis]) => {
        const filteredEmojis = filter ? emojis.filter((emoji) => {
          const keywords = EMOJI_KEYWORDS[emoji] || "";
          return keywords.toLowerCase().includes(filter) || emoji.includes(filter);
        }) : emojis;
        if (filteredEmojis.length === 0)
          return;
        const categoryDiv = gridContainer.createDiv({ cls: "immerse-emoji-category" });
        categoryDiv.createEl("h3", { text: category, cls: "immerse-emoji-category-title" });
        const grid = categoryDiv.createDiv({ cls: "immerse-emoji-grid" });
        filteredEmojis.forEach((emoji) => {
          const button = grid.createEl("button", {
            text: emoji,
            cls: "immerse-emoji-button"
          });
          if (emoji === this.currentEmoji) {
            button.addClass("immerse-emoji-selected");
          }
          button.addEventListener("click", () => {
            this.onSelect(emoji);
            this.close();
          });
        });
      });
    };
    renderCategories();
    searchInput.addEventListener("input", (e) => {
      const filter = e.target.value.toLowerCase();
      renderCategories(filter);
    });
    const customDiv = contentEl.createDiv({ cls: "immerse-emoji-custom" });
    customDiv.createEl("span", { text: "Or enter custom emoji: " });
    const customInput = customDiv.createEl("input", {
      type: "text",
      placeholder: "Paste emoji",
      cls: "immerse-emoji-custom-input"
    });
    const customBtn = customDiv.createEl("button", {
      text: "Use Custom",
      cls: "immerse-btn immerse-btn-primary"
    });
    customBtn.addEventListener("click", () => {
      const customEmoji = customInput.value.trim();
      if (customEmoji) {
        this.onSelect(customEmoji);
        this.close();
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/view.ts
var ImmerseView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.currentFilter = "all";
    // References to elements that need frequent updates
    this.timerTimeEl = null;
    this.progressBarEl = null;
    this.actualTimeEl = null;
    this.pauseBtnEl = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_IMMERSE;
  }
  getDisplayText() {
    return "Immerse";
  }
  getIcon() {
    return "zap";
  }
  async onOpen() {
    this.refresh();
  }
  // Light update - only updates timer display without rebuilding DOM
  updateTimerDisplay() {
    if (!this.timerTimeEl)
      return;
    this.timerTimeEl.textContent = this.plugin.formatTime(this.plugin.currentTimerSeconds);
    if (this.progressBarEl) {
      let progressPercent = 0;
      if (this.plugin.isBreakMode) {
        const breakDuration = this.plugin.pomodoroCount % this.plugin.settings.longBreakInterval === 0 ? this.plugin.settings.longBreakMinutes * 60 : this.plugin.settings.pomodoroBreakMinutes * 60;
        progressPercent = (breakDuration - this.plugin.currentTimerSeconds) / breakDuration * 100;
      } else {
        const workDuration = this.plugin.settings.pomodoroWorkMinutes * 60;
        progressPercent = (workDuration - this.plugin.currentTimerSeconds) / workDuration * 100;
      }
      this.progressBarEl.style.width = `${Math.min(Math.max(progressPercent, 0), 100)}%`;
    }
    if (this.actualTimeEl && this.plugin.activeTaskId) {
      const task = this.plugin.data.tasks.find((t) => t.id === this.plugin.activeTaskId);
      if (task) {
        this.actualTimeEl.textContent = `Actual: ${this.plugin.formatTimeHuman(task.actualMinutes)}`;
      }
    }
  }
  refresh() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("immerse-container");
    this.timerTimeEl = null;
    this.progressBarEl = null;
    this.actualTimeEl = null;
    this.pauseBtnEl = null;
    this.renderHeader(container);
    this.renderStatsBar(container);
    this.renderActiveTask(container);
    this.renderTaskList(container);
  }
  renderHeader(container) {
    const header = container.createEl("div", { cls: "immerse-header" });
    const titleSection = header.createEl("div", { cls: "immerse-title-section" });
    titleSection.createEl("h2", { text: "\u26A1 Immerse", cls: "immerse-title" });
    const today = new Date();
    const dateStr = today.toLocaleDateString("en-US", { weekday: "long", month: "short", day: "numeric" });
    titleSection.createEl("div", { text: dateStr, cls: "immerse-date" });
    const actions = header.createEl("div", { cls: "immerse-header-actions" });
    const reportsBtn = actions.createEl("button", { cls: "immerse-btn" });
    reportsBtn.innerHTML = "\u{1F4CA} Reports";
    reportsBtn.addEventListener("click", () => {
      this.plugin.activateReportView();
    });
    const addBtn = actions.createEl("button", { cls: "immerse-btn immerse-btn-primary" });
    addBtn.innerHTML = "+ Add Task";
    addBtn.addEventListener("click", () => {
      new QuickAddTaskModal(this.app, this.plugin).open();
    });
  }
  renderStatsBar(container) {
    const stats = this.plugin.getStats();
    const statsBar = container.createEl("div", { cls: "immerse-stats-bar" });
    const statItems = [
      { label: "Pending", value: stats.pendingCount.toString(), icon: "\u{1F4CB}" },
      { label: "Done Today", value: stats.completedToday.toString(), icon: "\u2705" },
      { label: "Today's Focus", value: this.plugin.formatTimeHuman(stats.totalFocusMinutesToday), icon: "\u23F1\uFE0F" },
      { label: "Streak", value: `${stats.streak} days`, icon: "\u{1F525}" }
    ];
    statItems.forEach((stat) => {
      const item = statsBar.createEl("div", { cls: "immerse-stat-item" });
      item.createEl("div", { cls: "immerse-stat-icon", text: stat.icon });
      item.createEl("div", { cls: "immerse-stat-value", text: stat.value });
      item.createEl("div", { cls: "immerse-stat-label", text: stat.label });
    });
  }
  renderActiveTask(container) {
    const activeSection = container.createEl("div", { cls: "immerse-active-section" });
    if (this.plugin.activeTaskId) {
      const task = this.plugin.data.tasks.find((t) => t.id === this.plugin.activeTaskId);
      if (task) {
        activeSection.addClass("immerse-has-active");
        const activeCard = activeSection.createEl("div", { cls: "immerse-active-card" });
        if (this.plugin.isBreakMode) {
          activeCard.addClass("immerse-break-card");
          const breakLabel = this.plugin.currentTimerSeconds > 0 ? "\u2615 BREAK TIME" : "\u2728 BREAK COMPLETE";
          activeCard.createEl("div", { cls: "immerse-active-label", text: breakLabel });
        } else {
          let workLabel;
          if (this.plugin.currentTimerSeconds > 0 || this.plugin.isStopwatchMode) {
            workLabel = "\u{1F3AF} FOCUSING ON";
          } else {
            workLabel = "\u{1F345} POMODORO COMPLETE";
          }
          activeCard.createEl("div", { cls: "immerse-active-label", text: workLabel });
        }
        activeCard.createEl("div", { cls: "immerse-active-task-name", text: task.text });
        const timerDisplay = activeCard.createEl("div", { cls: "immerse-timer-display" });
        this.timerTimeEl = timerDisplay.createEl("span", {
          cls: "immerse-timer-time",
          text: this.plugin.formatTime(this.plugin.currentTimerSeconds)
        });
        if (!this.plugin.isStopwatchMode) {
          const progressWrap = activeCard.createEl("div", { cls: "immerse-progress-wrap" });
          this.progressBarEl = progressWrap.createEl("div", { cls: "immerse-progress-bar" });
          let progressPercent = 0;
          if (this.plugin.isBreakMode) {
            const breakDuration = this.plugin.pomodoroCount % this.plugin.settings.longBreakInterval === 0 ? this.plugin.settings.longBreakMinutes * 60 : this.plugin.settings.pomodoroBreakMinutes * 60;
            progressPercent = (breakDuration - this.plugin.currentTimerSeconds) / breakDuration * 100;
          } else {
            const workDuration = this.plugin.settings.pomodoroWorkMinutes * 60;
            progressPercent = (workDuration - this.plugin.currentTimerSeconds) / workDuration * 100;
          }
          this.progressBarEl.style.width = `${Math.min(Math.max(progressPercent, 0), 100)}%`;
          if (progressPercent >= 100)
            this.progressBarEl.addClass("immerse-overtime");
        }
        if (!this.plugin.isBreakMode) {
          const timeInfo = activeCard.createEl("div", { cls: "immerse-time-info" });
          timeInfo.createEl("span", { text: `Est: ${this.plugin.formatTimeHuman(task.estimatedMinutes)}` });
          this.actualTimeEl = timeInfo.createEl("span", { text: `Actual: ${this.plugin.formatTimeHuman(task.actualMinutes)}` });
        }
        const controls = activeCard.createEl("div", { cls: "immerse-active-controls" });
        if (this.plugin.isBreakMode) {
          if (this.plugin.currentTimerSeconds > 0) {
            this.pauseBtnEl = controls.createEl("button", { cls: "immerse-btn immerse-btn-secondary" });
            this.pauseBtnEl.innerHTML = this.plugin.isTimerRunning ? "\u23F8 Pause" : "\u25B6 Resume";
            this.pauseBtnEl.addEventListener("click", () => this.plugin.toggleTimer());
            const skipBreakBtn = controls.createEl("button", { cls: "immerse-btn immerse-btn-primary" });
            skipBreakBtn.innerHTML = "\u23ED Skip Break";
            skipBreakBtn.addEventListener("click", () => {
              this.plugin.isBreakMode = false;
              this.plugin.startPomodoro(task.id);
            });
            const stopBtn = controls.createEl("button", { cls: "immerse-btn immerse-btn-danger" });
            stopBtn.innerHTML = "\u2715 Stop";
            stopBtn.addEventListener("click", () => {
              this.plugin.isBreakMode = false;
              this.plugin.stopTimer();
            });
          } else {
            const resumeWorkBtn = controls.createEl("button", { cls: "immerse-btn immerse-btn-success" });
            resumeWorkBtn.innerHTML = "\u25B6 Resume Work";
            resumeWorkBtn.addEventListener("click", () => {
              this.plugin.isBreakMode = false;
              this.plugin.startPomodoro(task.id);
            });
            const stopBtn = controls.createEl("button", { cls: "immerse-btn immerse-btn-danger" });
            stopBtn.innerHTML = "\u2715 Stop";
            stopBtn.addEventListener("click", () => {
              this.plugin.isBreakMode = false;
              this.plugin.stopTimer();
            });
          }
        } else {
          if (this.plugin.currentTimerSeconds > 0 || this.plugin.isStopwatchMode) {
            this.pauseBtnEl = controls.createEl("button", { cls: "immerse-btn immerse-btn-secondary" });
            this.pauseBtnEl.innerHTML = this.plugin.isTimerRunning ? "\u23F8 Pause" : "\u25B6 Resume";
            this.pauseBtnEl.addEventListener("click", () => this.plugin.toggleTimer());
            const completeBtn = controls.createEl("button", { cls: "immerse-btn immerse-btn-success" });
            completeBtn.innerHTML = "\u2713 Complete";
            completeBtn.addEventListener("click", () => this.plugin.completeTask(task.id));
            const stopBtn = controls.createEl("button", { cls: "immerse-btn immerse-btn-danger" });
            stopBtn.innerHTML = "\u2715 Stop";
            stopBtn.addEventListener("click", () => this.plugin.stopTimer());
          } else {
            const startBreakBtn = controls.createEl("button", { cls: "immerse-btn immerse-btn-secondary" });
            startBreakBtn.innerHTML = "\u2615 Start Break";
            startBreakBtn.addEventListener("click", () => this.plugin.startBreak());
            const continueBtn = controls.createEl("button", { cls: "immerse-btn immerse-btn-primary" });
            continueBtn.innerHTML = "\u25B6 Continue Working";
            continueBtn.addEventListener("click", () => this.plugin.startPomodoro(task.id));
            const completeBtn = controls.createEl("button", { cls: "immerse-btn immerse-btn-success" });
            completeBtn.innerHTML = "\u2713 Complete";
            completeBtn.addEventListener("click", () => this.plugin.completeTask(task.id));
            const stopBtn = controls.createEl("button", { cls: "immerse-btn immerse-btn-danger" });
            stopBtn.innerHTML = "\u2715 Stop";
            stopBtn.addEventListener("click", () => this.plugin.stopTimer());
          }
        }
      }
    } else {
      const startPrompt = activeSection.createEl("div", { cls: "immerse-start-prompt" });
      startPrompt.createEl("div", { cls: "immerse-prompt-icon", text: "\u26A1" });
      startPrompt.createEl("div", { cls: "immerse-prompt-text", text: "Ready to focus?" });
      startPrompt.createEl("div", { cls: "immerse-prompt-hint", text: "Click \u25B6 on a task to start a Pomodoro session" });
    }
  }
  renderTaskList(container) {
    const listSection = container.createEl("div", { cls: "immerse-list-section" });
    const filters = listSection.createEl("div", { cls: "immerse-filters" });
    const filterOptions = [
      { id: "all", label: "All Tasks" },
      { id: "today", label: "Today" },
      { id: "completed", label: "Completed" },
      ...this.plugin.settings.lists.map((l) => ({ id: l.id, label: `${l.icon} ${l.name}` }))
    ];
    filterOptions.forEach((opt) => {
      const btn = filters.createEl("button", {
        cls: `immerse-filter-btn ${this.currentFilter === opt.id ? "active" : ""}`,
        text: opt.label
      });
      btn.addEventListener("click", () => {
        this.currentFilter = opt.id;
        this.refresh();
      });
    });
    const taskList = listSection.createEl("div", { cls: "immerse-task-list" });
    let tasks = this.plugin.data.tasks;
    if (this.currentFilter === "today") {
      tasks = this.plugin.getTodaysTasks();
    } else if (this.currentFilter === "completed") {
      tasks = this.plugin.data.tasks.filter((t) => t.completed);
    } else if (this.currentFilter !== "all") {
      tasks = this.plugin.getTasksByList(this.currentFilter);
    }
    tasks = [...tasks].sort((a, b) => {
      if (a.completed !== b.completed)
        return a.completed ? 1 : -1;
      return b.createdAt - a.createdAt;
    });
    if (tasks.length === 0) {
      const emptyState = taskList.createEl("div", { cls: "immerse-empty-state" });
      emptyState.createEl("div", { cls: "immerse-empty-icon", text: "\u{1F4DD}" });
      emptyState.createEl("div", { cls: "immerse-empty-text", text: "No tasks yet" });
      emptyState.createEl("div", { cls: "immerse-empty-hint", text: "Add a task to get started!" });
    } else {
      tasks.forEach((task) => this.renderTaskItem(taskList, task));
    }
  }
  renderTaskItem(container, task) {
    const list = this.plugin.settings.lists.find((l) => l.id === task.list);
    const isOverdue = !task.completed && task.scheduledDate && task.scheduledTime && new Date(`${task.scheduledDate}T${task.scheduledTime}`).getTime() < Date.now();
    const taskEl = container.createEl("div", {
      cls: `immerse-task-item ${task.completed ? "completed" : ""} ${task.isActive ? "active" : ""} ${isOverdue ? "overdue" : ""}`
    });
    const checkbox = taskEl.createEl("div", { cls: "immerse-checkbox" });
    checkbox.innerHTML = task.completed ? "\u2713" : "";
    checkbox.style.borderColor = (list == null ? void 0 : list.color) || "#6366f1";
    if (task.completed) {
      checkbox.style.backgroundColor = (list == null ? void 0 : list.color) || "#6366f1";
      checkbox.style.color = "white";
    }
    checkbox.addEventListener("click", (e) => {
      e.stopPropagation();
      if (!task.completed) {
        this.plugin.completeTask(task.id);
      }
    });
    const content = taskEl.createEl("div", { cls: "immerse-task-content" });
    const taskHeader = content.createEl("div", { cls: "immerse-task-header" });
    taskHeader.createEl("span", { cls: "immerse-task-text", text: task.text });
    if (list) {
      const listBadge = taskHeader.createEl("span", {
        cls: "immerse-list-badge",
        text: `${list.icon} ${list.name}`
      });
      listBadge.style.backgroundColor = list.color + "20";
      listBadge.style.color = list.color;
    }
    const taskMeta = content.createEl("div", { cls: "immerse-task-meta" });
    taskMeta.createEl("span", { text: `Est: ${this.plugin.formatTimeHuman(task.estimatedMinutes)}` });
    if (task.actualMinutes > 0) {
      const actualSpan = taskMeta.createEl("span");
      actualSpan.setText(`Actual: ${this.plugin.formatTimeHuman(task.actualMinutes)}`);
      if (task.actualMinutes > task.estimatedMinutes) {
        actualSpan.addClass("immerse-overtime-text");
      }
    }
    if (task.scheduledDate) {
      const scheduleSpan = taskMeta.createEl("span", {
        cls: `immerse-schedule-badge ${isOverdue ? "overdue" : ""}`
      });
      const dateStr = task.scheduledDate;
      const timeStr = task.scheduledTime || "";
      if (isOverdue) {
        scheduleSpan.setText(`\u26A0\uFE0F OVERDUE: ${dateStr}${timeStr ? " " + timeStr : ""}`);
      } else {
        scheduleSpan.setText(`\u{1F4C5} ${dateStr}${timeStr ? " " + timeStr : ""}`);
      }
      if (task.reminderMinutes) {
        scheduleSpan.title = `Reminder set for ${task.reminderMinutes} min before`;
      }
    }
    const actions = taskEl.createEl("div", { cls: "immerse-task-actions" });
    if (!task.completed) {
      const startBtn = actions.createEl("button", { cls: "immerse-task-btn", attr: { "aria-label": "Start Pomodoro" } });
      startBtn.innerHTML = "\u25B6";
      startBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.plugin.startPomodoro(task.id);
      });
      const stopwatchBtn = actions.createEl("button", { cls: "immerse-task-btn", attr: { "aria-label": "Start Stopwatch" } });
      stopwatchBtn.innerHTML = "\u23F1";
      stopwatchBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.plugin.startTimer(task.id);
      });
    }
    const editBtn = actions.createEl("button", { cls: "immerse-task-btn", attr: { "aria-label": "Edit" } });
    editBtn.innerHTML = "\u270F\uFE0F";
    editBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      new EditTaskModal(this.app, this.plugin, task).open();
    });
    const deleteBtn = actions.createEl("button", { cls: "immerse-task-btn immerse-delete-btn", attr: { "aria-label": "Delete" } });
    deleteBtn.innerHTML = "\u{1F5D1}";
    deleteBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.plugin.deleteTask(task.id);
    });
  }
};

// src/reportView.ts
var import_obsidian3 = require("obsidian");
var VIEW_TYPE_REPORT = "immerse-report-view";
var ReportView = class extends import_obsidian3.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.selectedListIds = [];
    this.activeQuickFilter = "Last 7 days";
    // Track active filter
    this.startDateInput = null;
    this.endDateInput = null;
    this.plugin = plugin;
    const today = new Date();
    this.endDate = today.toISOString().split("T")[0];
    const weekAgo = new Date(today);
    weekAgo.setDate(weekAgo.getDate() - 7);
    this.startDate = weekAgo.toISOString().split("T")[0];
  }
  getViewType() {
    return VIEW_TYPE_REPORT;
  }
  getDisplayText() {
    return "\u{1F4CA} Reports";
  }
  getIcon() {
    return "bar-chart-2";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("immerse-report-view");
    this.renderContent();
  }
  async onClose() {
  }
  renderContent() {
    const container = this.containerEl.children[1];
    container.empty();
    const header = container.createEl("div", { cls: "immerse-report-header" });
    header.createEl("h2", { text: "\u{1F4CA} Reports", cls: "immerse-report-title" });
    this.renderFilters(container);
    const generateBtn = container.createEl("button", {
      text: "\u{1F504} Generate Report",
      cls: "immerse-btn immerse-btn-primary immerse-report-generate-btn"
    });
    generateBtn.addEventListener("click", () => this.renderReport(container));
    this.renderReport(container);
  }
  renderFilters(container) {
    const filtersSection = container.createEl("div", { cls: "immerse-report-filters" });
    const dateRow = filtersSection.createEl("div", { cls: "immerse-report-filter-row" });
    new import_obsidian3.Setting(dateRow).setName("Start Date").addText((text) => {
      text.setValue(this.startDate).onChange((value) => {
        this.startDate = value;
        this.activeQuickFilter = null;
      });
      text.inputEl.type = "date";
      this.startDateInput = text.inputEl;
    });
    new import_obsidian3.Setting(dateRow).setName("End Date").addText((text) => {
      text.setValue(this.endDate).onChange((value) => {
        this.endDate = value;
        this.activeQuickFilter = null;
      });
      text.inputEl.type = "date";
      this.endDateInput = text.inputEl;
    });
    const quickFilters = filtersSection.createEl("div", { cls: "immerse-report-quick-filters" });
    quickFilters.createEl("span", { text: "Quick select: ", cls: "immerse-filter-label" });
    const filters = [
      { label: "Today", days: 0 },
      { label: "Last 7 days", days: 7 },
      { label: "Last 30 days", days: 30 },
      { label: "Last 90 days", days: 90 }
    ];
    filters.forEach((filter) => {
      const btn = quickFilters.createEl("button", {
        text: filter.label,
        cls: "immerse-quick-filter-btn"
      });
      if (filter.label === this.activeQuickFilter) {
        btn.addClass("active");
      }
      btn.addEventListener("click", () => {
        const today = new Date();
        this.endDate = today.toISOString().split("T")[0];
        const startDate = new Date(today);
        startDate.setDate(startDate.getDate() - filter.days);
        this.startDate = startDate.toISOString().split("T")[0];
        if (this.startDateInput)
          this.startDateInput.value = this.startDate;
        if (this.endDateInput)
          this.endDateInput.value = this.endDate;
        this.activeQuickFilter = filter.label;
        quickFilters.querySelectorAll(".immerse-quick-filter-btn").forEach((b) => {
          b.removeClass("active");
        });
        btn.addClass("active");
        this.renderReport(container);
      });
    });
  }
  renderReport(container) {
    const oldReport = container.querySelector(".immerse-report-content");
    if (oldReport)
      oldReport.remove();
    const filters = {
      startDate: this.startDate,
      endDate: this.endDate,
      listIds: this.selectedListIds.length > 0 ? this.selectedListIds : void 0
    };
    const reportData = this.plugin.generateReport(filters);
    const reportContent = container.createEl("div", { cls: "immerse-report-content" });
    if (reportData.totalTasks === 0) {
      reportContent.createEl("div", {
        text: "No data available for the selected period. Complete some tasks to see your stats!",
        cls: "immerse-no-data-message"
      });
      return;
    }
    this.renderSummaryStats(reportContent, reportData);
    if (reportData.timeByList.length > 0) {
      this.renderTimeByList(reportContent, reportData);
    }
    this.renderInsights(reportContent, reportData);
    if (reportData.dailyBreakdown.length > 0) {
      this.renderDailyBreakdown(reportContent, reportData);
    }
  }
  renderSummaryStats(container, data) {
    const statsGrid = container.createEl("div", { cls: "immerse-stats-grid" });
    const stats = [
      { label: "TASKS DONE", value: data.totalTasks.toString(), icon: "\u2713" },
      { label: "TASKS PER DAY", value: data.tasksPerDay.toFixed(1), icon: "\u{1F4C5}" },
      { label: "HOURS PER DAY", value: data.hoursPerDay.toFixed(1), icon: "\u23F0" },
      { label: "MINS PER TASK", value: data.minsPerTask.toString(), icon: "\u23F1\uFE0F" },
      { label: "DAY STREAK", value: data.currentStreak.toString(), icon: "\u{1F525}" },
      { label: "TOTAL HOURS", value: (data.totalMinutes / 60).toFixed(1), icon: "\u231A" }
    ];
    stats.forEach((stat) => {
      const statCard = statsGrid.createEl("div", { cls: "immerse-stat-card" });
      statCard.createEl("div", { text: stat.label, cls: "immerse-stat-label" });
      const valueRow = statCard.createEl("div", { cls: "immerse-stat-value-row" });
      valueRow.createEl("span", { text: stat.icon, cls: "immerse-stat-icon" });
      valueRow.createEl("span", { text: stat.value, cls: "immerse-stat-value" });
    });
  }
  renderTimeByList(container, data) {
    const section = container.createEl("div", { cls: "immerse-report-section" });
    section.createEl("h3", { text: "Time by List", cls: "immerse-report-section-title" });
    const listContainer = section.createEl("div", { cls: "immerse-time-by-list" });
    data.timeByList.forEach((item) => {
      const listItem = listContainer.createEl("div", { cls: "immerse-list-stat-item" });
      const listInfo = listItem.createEl("div", { cls: "immerse-list-info" });
      listInfo.createEl("span", { text: item.listIcon, cls: "immerse-list-icon" });
      listInfo.createEl("span", { text: item.listName, cls: "immerse-list-name" });
      const progressBar = listItem.createEl("div", { cls: "immerse-list-progress" });
      const progress = progressBar.createEl("div", { cls: "immerse-list-progress-fill" });
      progress.style.width = `${item.percentage}%`;
      progress.style.background = item.listColor;
      const stats = listItem.createEl("div", { cls: "immerse-list-stats" });
      stats.createEl("span", {
        text: `${item.taskCount} tasks`,
        cls: "immerse-list-stat-text"
      });
      stats.createEl("span", {
        text: `${this.plugin.formatTimeHuman(item.minutes)}`,
        cls: "immerse-list-stat-text"
      });
      stats.createEl("span", {
        text: `${item.percentage.toFixed(1)}%`,
        cls: "immerse-list-stat-percentage"
      });
    });
  }
  renderInsights(container, data) {
    const section = container.createEl("div", { cls: "immerse-report-section" });
    section.createEl("h3", { text: "Productivity Insights", cls: "immerse-report-section-title" });
    const insightsGrid = section.createEl("div", { cls: "immerse-insights-grid" });
    if (data.mostProductiveHour !== void 0) {
      const card = insightsGrid.createEl("div", { cls: "immerse-insight-card" });
      card.createEl("span", { text: "\u{1F550}", cls: "immerse-insight-icon" });
      card.createEl("span", { text: "MOST PRODUCTIVE HOUR", cls: "immerse-insight-label" });
      card.createEl("span", {
        text: `${data.mostProductiveHour}:00 - ${data.mostProductiveHour + 1}:00`,
        cls: "immerse-insight-value"
      });
    }
    if (data.mostProductiveDay) {
      const card = insightsGrid.createEl("div", { cls: "immerse-insight-card" });
      card.createEl("span", { text: "\u{1F4C5}", cls: "immerse-insight-icon" });
      card.createEl("span", { text: "MOST PRODUCTIVE DAY", cls: "immerse-insight-label" });
      card.createEl("span", { text: data.mostProductiveDay, cls: "immerse-insight-value" });
    }
    if (data.mostProductiveMonth) {
      const card = insightsGrid.createEl("div", { cls: "immerse-insight-card" });
      card.createEl("span", { text: "\u{1F5D3}\uFE0F", cls: "immerse-insight-icon" });
      card.createEl("span", { text: "MOST PRODUCTIVE MONTH", cls: "immerse-insight-label" });
      card.createEl("span", { text: data.mostProductiveMonth, cls: "immerse-insight-value" });
    }
  }
  renderPieChart(container, data) {
    const pieContainer = container.createEl("div", { cls: "immerse-daily-pie-container" });
    const totalTasks = data.totalTasks;
    const totalMinutes = data.totalMinutes;
    const totalPomodoros = data.totalPomodoros;
    const taskMinutes = totalTasks * data.minsPerTask;
    const pomodoroMinutes = totalPomodoros * 25;
    const totalTime = taskMinutes + totalMinutes + pomodoroMinutes;
    if (totalTime === 0)
      return;
    const tasksPercent = taskMinutes / totalTime * 100;
    const hoursPercent = totalMinutes / totalTime * 100;
    const pomodorosPercent = pomodoroMinutes / totalTime * 100;
    const tasksDeg = tasksPercent / 100 * 360;
    const hoursDeg = tasksDeg + hoursPercent / 100 * 360;
    const pieChart = pieContainer.createEl("div", { cls: "immerse-daily-pie-chart" });
    const gradient = `conic-gradient(from 0deg, #6366f1 0deg ${tasksDeg}deg, #22c55e ${tasksDeg}deg ${hoursDeg}deg, #f59e0b ${hoursDeg}deg 360deg)`;
    pieChart.style.background = gradient;
    const center = pieChart.createEl("div", { cls: "immerse-daily-pie-center" });
    center.createEl("div", { text: data.totalTasks.toString(), cls: "immerse-daily-pie-center-value" });
    center.createEl("div", { text: "TOTAL TASKS", cls: "immerse-daily-pie-center-label" });
    const legend = pieContainer.createEl("div", { cls: "immerse-daily-pie-legend" });
    const tasksItem = legend.createEl("div", { cls: "immerse-daily-pie-legend-item" });
    const tasksColor = tasksItem.createEl("div", { cls: "immerse-daily-pie-legend-color" });
    tasksColor.style.background = "#6366f1";
    const tasksInfo = tasksItem.createEl("div", { cls: "immerse-daily-pie-legend-info" });
    const tasksLabel = tasksInfo.createEl("div", { cls: "immerse-daily-pie-legend-label" });
    tasksLabel.createEl("span", { text: "\u2713" });
    tasksLabel.appendText("Tasks Completed");
    tasksInfo.createEl("div", { text: totalTasks.toString(), cls: "immerse-daily-pie-legend-value" });
    tasksInfo.createEl("div", { text: `${tasksPercent.toFixed(1)}%`, cls: "immerse-daily-pie-legend-percentage" });
    const hoursItem = legend.createEl("div", { cls: "immerse-daily-pie-legend-item" });
    const hoursColor = hoursItem.createEl("div", { cls: "immerse-daily-pie-legend-color" });
    hoursColor.style.background = "#22c55e";
    const hoursInfo = hoursItem.createEl("div", { cls: "immerse-daily-pie-legend-info" });
    const hoursLabel = hoursInfo.createEl("div", { cls: "immerse-daily-pie-legend-label" });
    hoursLabel.createEl("span", { text: "\u23F1\uFE0F" });
    hoursLabel.appendText("Total Hours");
    hoursInfo.createEl("div", { text: (totalMinutes / 60).toFixed(1), cls: "immerse-daily-pie-legend-value" });
    hoursInfo.createEl("div", { text: `${hoursPercent.toFixed(1)}%`, cls: "immerse-daily-pie-legend-percentage" });
    const pomodorosItem = legend.createEl("div", { cls: "immerse-daily-pie-legend-item" });
    const pomodorosColor = pomodorosItem.createEl("div", { cls: "immerse-daily-pie-legend-color" });
    pomodorosColor.style.background = "#f59e0b";
    const pomodorosInfo = pomodorosItem.createEl("div", { cls: "immerse-daily-pie-legend-info" });
    const pomodorosLabel = pomodorosInfo.createEl("div", { cls: "immerse-daily-pie-legend-label" });
    pomodorosLabel.createEl("span", { text: "\u{1F345}" });
    pomodorosLabel.appendText("Pomodoros");
    pomodorosInfo.createEl("div", { text: totalPomodoros.toString(), cls: "immerse-daily-pie-legend-value" });
    pomodorosInfo.createEl("div", { text: `${pomodorosPercent.toFixed(1)}%`, cls: "immerse-daily-pie-legend-percentage" });
  }
  renderDailyBreakdown(container, data) {
    const section = container.createEl("div", { cls: "immerse-report-section" });
    section.createEl("h3", { text: "Daily Breakdown", cls: "immerse-report-section-title" });
    this.renderPieChart(section, data);
    const breakdownContainer = section.createEl("div", { cls: "immerse-daily-breakdown-container" });
    const recentData = data.dailyBreakdown.slice(-10);
    const maxTasks = Math.max(...recentData.map((d) => d.tasks), 1);
    const maxHours = Math.max(...recentData.map((d) => d.hours), 1);
    const maxPomodoros = Math.max(...recentData.map((d) => d.pomodoros), 1);
    recentData.forEach((day) => {
      const row = breakdownContainer.createEl("div", { cls: "immerse-daily-row" });
      const dateEl = row.createEl("div", { cls: "immerse-daily-date" });
      const date = new Date(day.date + "T00:00:00");
      const dayName = date.toLocaleDateString("en-US", { weekday: "short" }).toUpperCase();
      const monthDay = date.toLocaleDateString("en-US", { month: "short", day: "numeric" });
      dateEl.createEl("div", { text: dayName, cls: "immerse-daily-date-day" });
      dateEl.createEl("div", { text: monthDay, cls: "immerse-daily-date-num" });
      const barsContainer = row.createEl("div", { cls: "immerse-daily-bars" });
      const tasksRow = barsContainer.createEl("div", { cls: "immerse-daily-bar-row" });
      const tasksLabel = tasksRow.createEl("span", { cls: "immerse-daily-bar-label" });
      tasksLabel.createEl("span", { text: "\u2713", cls: "immerse-daily-bar-icon" });
      tasksLabel.appendText("Tasks");
      const tasksTrack = tasksRow.createEl("div", { cls: "immerse-daily-bar-track" });
      const tasksFill = tasksTrack.createEl("div", { cls: "immerse-daily-bar-fill tasks" });
      tasksFill.style.width = `${day.tasks / maxTasks * 100}%`;
      tasksRow.createEl("span", { text: day.tasks.toString(), cls: "immerse-daily-bar-value" });
      const hoursRow = barsContainer.createEl("div", { cls: "immerse-daily-bar-row" });
      const hoursLabel = hoursRow.createEl("span", { cls: "immerse-daily-bar-label" });
      hoursLabel.createEl("span", { text: "\u23F1\uFE0F", cls: "immerse-daily-bar-icon" });
      hoursLabel.appendText("Hours");
      const hoursTrack = hoursRow.createEl("div", { cls: "immerse-daily-bar-track" });
      const hoursFill = hoursTrack.createEl("div", { cls: "immerse-daily-bar-fill hours" });
      hoursFill.style.width = `${day.hours / maxHours * 100}%`;
      hoursRow.createEl("span", { text: day.hours.toFixed(1), cls: "immerse-daily-bar-value" });
      const pomodorosRow = barsContainer.createEl("div", { cls: "immerse-daily-bar-row" });
      const pomodorosLabel = pomodorosRow.createEl("span", { cls: "immerse-daily-bar-label" });
      pomodorosLabel.createEl("span", { text: "\u{1F345}", cls: "immerse-daily-bar-icon" });
      pomodorosLabel.appendText("Pomodoros");
      const pomodorosTrack = pomodorosRow.createEl("div", { cls: "immerse-daily-bar-track" });
      const pomodorosFill = pomodorosTrack.createEl("div", { cls: "immerse-daily-bar-fill pomodoros" });
      pomodorosFill.style.width = `${day.pomodoros / maxPomodoros * 100}%`;
      pomodorosRow.createEl("span", { text: day.pomodoros.toString(), cls: "immerse-daily-bar-value" });
    });
  }
};

// src/main.ts
var ImmersePlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    // Timer state
    this.timerInterval = null;
    this.currentTimerSeconds = 0;
    this.isTimerRunning = false;
    this.isBreakMode = false;
    this.isStopwatchMode = false;
    this.activeTaskId = null;
    this.pomodoroCount = 0;
    // Timestamp-based tracking for reliable background timing
    this.timerStartTimestamp = 0;
    this.pausedTimeRemaining = 0;
    // Focus time tracking (in seconds for accuracy)
    this.focusSecondsToday = 0;
    this.secondsWorkedOnCurrentTask = 0;
    this.sessionStartSeconds = 0;
    // Track seconds at start of current session
    // Status bar element
    this.statusBarEl = null;
    // Reminder system
    this.reminderCheckInterval = null;
    this.notifiedReminders = /* @__PURE__ */ new Set();
    // Track which reminders have been shown
    // Daily reset check interval
    this.dailyResetCheckInterval = null;
  }
  async onload() {
    await this.loadAllData();
    this.checkDailyReset();
    this.dailyResetCheckInterval = window.setInterval(() => {
      this.checkDailyReset();
    }, 6e4);
    document.addEventListener("visibilitychange", () => {
      if (!document.hidden) {
        this.checkDailyReset();
        if (this.isTimerRunning) {
          this.syncTimerFromTimestamp();
        }
      }
    });
    this.registerView(
      VIEW_TYPE_IMMERSE,
      (leaf) => new ImmerseView(leaf, this)
    );
    this.registerView(
      VIEW_TYPE_REPORT,
      (leaf) => new ReportView(leaf, this)
    );
    this.addRibbonIcon("zap", "Open Immerse", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-immerse",
      name: "Open Immerse Panel",
      callback: () => this.activateView()
    });
    this.addCommand({
      id: "quick-add-task",
      name: "Quick Add Task",
      callback: () => new QuickAddTaskModal(this.app, this).open()
    });
    this.addCommand({
      id: "start-focus-mode",
      name: "Start Focus Mode on Next Task",
      callback: () => this.startFocusOnNextTask()
    });
    this.addCommand({
      id: "toggle-timer",
      name: "Toggle Timer (Play/Pause)",
      callback: () => this.toggleTimer()
    });
    this.addCommand({
      id: "complete-current-task",
      name: "Complete Current Task",
      callback: () => this.completeActiveTask()
    });
    this.addCommand({
      id: "view-reports",
      name: "View Reports",
      callback: () => this.activateReportView()
    });
    this.addSettingTab(new ImmerseSettingTab(this.app, this));
    this.createStatusBar();
    if (this.settings.enableReminders) {
      this.startReminderSystem();
    }
  }
  onunload() {
    this.stopTimer();
    this.stopReminderSystem();
    if (this.dailyResetCheckInterval) {
      window.clearInterval(this.dailyResetCheckInterval);
      this.dailyResetCheckInterval = null;
    }
  }
  async loadAllData() {
    const loaded = await this.loadData();
    this.data = Object.assign({}, DEFAULT_DATA, (loaded == null ? void 0 : loaded.data) || {});
    this.settings = Object.assign({}, DEFAULT_SETTINGS, (loaded == null ? void 0 : loaded.settings) || {});
    if (!this.settings.lists || this.settings.lists.length === 0) {
      this.settings.lists = DEFAULT_SETTINGS.lists;
    }
    this.focusSecondsToday = (this.data.totalFocusMinutesToday || 0) * 60;
  }
  async saveAllData() {
    this.data.totalFocusMinutesToday = Math.floor(this.focusSecondsToday / 60);
    await this.saveData({
      settings: this.settings,
      data: this.data
    });
  }
  checkDailyReset() {
    const today = new Date().toDateString();
    if (this.data.lastActiveDate !== today) {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      if (this.data.lastActiveDate === yesterday.toDateString()) {
        this.data.streak++;
      } else if (this.data.lastActiveDate !== today) {
        this.data.streak = 0;
      }
      this.data.completedToday = 0;
      this.data.totalFocusMinutesToday = 0;
      this.focusSecondsToday = 0;
      this.data.lastActiveDate = today;
      this.saveAllData();
    }
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_IMMERSE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_IMMERSE, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async activateReportView() {
    const { workspace } = this.app;
    const existingLeaves = workspace.getLeavesOfType(VIEW_TYPE_REPORT);
    if (existingLeaves.length > 0) {
      workspace.revealLeaf(existingLeaves[0]);
    } else {
      const leaf = workspace.getLeaf("tab");
      await leaf.setViewState({
        type: VIEW_TYPE_REPORT,
        active: true
      });
      workspace.revealLeaf(leaf);
    }
  }
  // ============ Task Management ============
  createTask(text, estimatedMinutes = this.settings.defaultEstimateMinutes, list = "work") {
    return {
      id: this.generateId(),
      text,
      completed: false,
      estimatedMinutes,
      actualMinutes: 0,
      createdAt: Date.now(),
      list,
      notes: "",
      isActive: false
    };
  }
  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }
  addTask(task) {
    this.data.tasks.push(task);
    this.saveAllData();
    this.refreshView();
  }
  updateTask(taskId, updates) {
    const task = this.data.tasks.find((t) => t.id === taskId);
    if (task) {
      Object.assign(task, updates);
      this.saveAllData();
      this.refreshView();
    }
  }
  deleteTask(taskId) {
    this.data.tasks = this.data.tasks.filter((t) => t.id !== taskId);
    if (this.activeTaskId === taskId) {
      this.stopTimer();
      this.activeTaskId = null;
    }
    this.saveAllData();
    this.refreshView();
  }
  completeTask(taskId) {
    const task = this.data.tasks.find((t) => t.id === taskId);
    if (task && !task.completed) {
      task.completed = true;
      task.completedAt = Date.now();
      task.isActive = false;
      this.data.completedToday++;
      this.data.lastActiveDate = new Date().toDateString();
      if (this.activeTaskId === taskId && this.sessionStartSeconds !== void 0) {
        const sessionTime = this.secondsWorkedOnCurrentTask - this.sessionStartSeconds;
        this.focusSecondsToday += sessionTime;
      }
      this.archiveCompletedTask(task);
      this.updateDailyStats(task);
      if (this.settings.enableCelebrations) {
        this.showCelebration(task);
      }
      if (this.settings.enableSounds) {
        this.playCompletionSound();
      }
      if (this.settings.logToDaily) {
        this.logTaskToDailyNote(task);
      }
      if (this.activeTaskId === taskId) {
        this.stopTimer();
        this.activeTaskId = null;
      }
      this.saveAllData();
      this.refreshView();
    }
  }
  completeActiveTask() {
    if (this.activeTaskId) {
      this.completeTask(this.activeTaskId);
    } else {
      new import_obsidian4.Notice("No active task to complete");
    }
  }
  // ============ Data Archiving & Statistics ============
  archiveCompletedTask(task) {
    const wasOverdue = task.scheduledDate && task.scheduledTime && new Date(`${task.scheduledDate}T${task.scheduledTime}`).getTime() < (task.completedAt || Date.now());
    const record = {
      id: task.id,
      text: task.text,
      list: task.list,
      estimatedMinutes: task.estimatedMinutes,
      actualMinutes: task.actualMinutes,
      createdAt: task.createdAt,
      completedAt: task.completedAt || Date.now(),
      scheduledDate: task.scheduledDate,
      wasOverdue: wasOverdue || false
    };
    this.data.completedTasksArchive.push(record);
  }
  updateDailyStats(task) {
    const today = new Date().toISOString().split("T")[0];
    let todayStats = this.data.dailyStats.find((s) => s.date === today);
    if (!todayStats) {
      todayStats = {
        date: today,
        tasksCompleted: 0,
        totalMinutes: 0,
        pomodorosCompleted: 0,
        tasksByList: {},
        minutesByList: {}
      };
      this.data.dailyStats.push(todayStats);
    }
    todayStats.tasksCompleted++;
    todayStats.totalMinutes += task.actualMinutes;
    todayStats.pomodorosCompleted = this.data.pomodorosCompleted;
    todayStats.tasksByList[task.list] = (todayStats.tasksByList[task.list] || 0) + 1;
    todayStats.minutesByList[task.list] = (todayStats.minutesByList[task.list] || 0) + task.actualMinutes;
    if (this.data.dailyStats.length > 365) {
      this.data.dailyStats.sort((a, b) => b.date.localeCompare(a.date));
      this.data.dailyStats = this.data.dailyStats.slice(0, 365);
    }
  }
  // ============ Report Generation ============
  generateReport(filters) {
    const { startDate, endDate, listIds } = filters;
    const filteredStats = this.data.dailyStats.filter((stat) => {
      return stat.date >= startDate && stat.date <= endDate;
    });
    const filteredTasks = this.data.completedTasksArchive.filter((task) => {
      const taskDate = new Date(task.completedAt).toISOString().split("T")[0];
      const inDateRange = taskDate >= startDate && taskDate <= endDate;
      const inList = !listIds || listIds.includes(task.list);
      return inDateRange && inList;
    });
    const totalTasks = filteredTasks.length;
    const totalMinutes = filteredTasks.reduce((sum, task) => sum + task.actualMinutes, 0);
    const totalPomodoros = filteredStats.reduce((sum, stat) => sum + stat.pomodorosCompleted, 0);
    const daysWithData = filteredStats.length || 1;
    const tasksPerDay = totalTasks / daysWithData;
    const hoursPerDay = totalMinutes / 60 / daysWithData;
    const minsPerTask = totalTasks > 0 ? totalMinutes / totalTasks : 0;
    const timeByListMap = {};
    filteredTasks.forEach((task) => {
      if (!timeByListMap[task.list]) {
        timeByListMap[task.list] = { minutes: 0, taskCount: 0 };
      }
      timeByListMap[task.list].minutes += task.actualMinutes;
      timeByListMap[task.list].taskCount++;
    });
    const timeByList = this.settings.lists.map((list) => {
      const data = timeByListMap[list.id] || { minutes: 0, taskCount: 0 };
      const percentage = totalMinutes > 0 ? data.minutes / totalMinutes * 100 : 0;
      return {
        listId: list.id,
        listName: list.name,
        listIcon: list.icon,
        listColor: list.color,
        minutes: data.minutes,
        taskCount: data.taskCount,
        percentage: Math.round(percentage * 10) / 10
        // Round to 1 decimal
      };
    }).filter((item) => item.minutes > 0);
    const dailyBreakdown = filteredStats.map((stat) => ({
      date: stat.date,
      tasks: stat.tasksCompleted,
      hours: Math.round(stat.totalMinutes / 60 * 10) / 10,
      pomodoros: stat.pomodorosCompleted
    }));
    const mostProductiveHour = this.calculateMostProductiveHour(filteredTasks);
    const mostProductiveDay = this.calculateMostProductiveDay(filteredStats);
    const mostProductiveMonth = this.calculateMostProductiveMonth(filteredStats);
    return {
      totalTasks,
      totalMinutes,
      totalPomodoros,
      tasksPerDay: Math.round(tasksPerDay * 10) / 10,
      hoursPerDay: Math.round(hoursPerDay * 10) / 10,
      minsPerTask: Math.round(minsPerTask),
      currentStreak: this.data.streak,
      timeByList,
      dailyBreakdown,
      mostProductiveHour,
      mostProductiveDay,
      mostProductiveMonth
    };
  }
  calculateMostProductiveHour(tasks) {
    if (tasks.length === 0)
      return void 0;
    const hourCounts = {};
    tasks.forEach((task) => {
      const hour = new Date(task.completedAt).getHours();
      hourCounts[hour] = (hourCounts[hour] || 0) + 1;
    });
    let maxHour = 0;
    let maxCount = 0;
    for (const [hour, count] of Object.entries(hourCounts)) {
      if (count > maxCount) {
        maxCount = count;
        maxHour = parseInt(hour);
      }
    }
    return maxCount > 0 ? maxHour : void 0;
  }
  calculateMostProductiveDay(stats) {
    if (stats.length === 0)
      return void 0;
    const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    const dayCounts = {};
    stats.forEach((stat) => {
      const dayOfWeek = new Date(stat.date).getDay();
      const dayName = dayNames[dayOfWeek];
      dayCounts[dayName] = (dayCounts[dayName] || 0) + stat.tasksCompleted;
    });
    let maxDay = "";
    let maxCount = 0;
    for (const [day, count] of Object.entries(dayCounts)) {
      if (count > maxCount) {
        maxCount = count;
        maxDay = day;
      }
    }
    return maxCount > 0 ? maxDay : void 0;
  }
  calculateMostProductiveMonth(stats) {
    if (stats.length === 0)
      return void 0;
    const monthNames = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    const monthCounts = {};
    stats.forEach((stat) => {
      const month = new Date(stat.date).getMonth();
      const monthName = monthNames[month];
      monthCounts[monthName] = (monthCounts[monthName] || 0) + stat.tasksCompleted;
    });
    let maxMonth = "";
    let maxCount = 0;
    for (const [month, count] of Object.entries(monthCounts)) {
      if (count > maxCount) {
        maxCount = count;
        maxMonth = month;
      }
    }
    return maxCount > 0 ? maxMonth : void 0;
  }
  // ============ Timer Management ============
  // Sync timer based on timestamp when app returns from background
  syncTimerFromTimestamp() {
    if (!this.isTimerRunning)
      return;
    this.updateStatusBar();
    this.updateTimerDisplay();
  }
  startTimer(taskId) {
    const task = this.data.tasks.find((t) => t.id === taskId);
    if (!task)
      return;
    this.stopTimer(true);
    this.activeTaskId = taskId;
    task.isActive = true;
    this.isBreakMode = false;
    this.isStopwatchMode = true;
    this.currentTimerSeconds = 0;
    this.isTimerRunning = true;
    this.secondsWorkedOnCurrentTask = task.actualMinutes * 60;
    this.timerStartTimestamp = Date.now();
    this.pausedTimeRemaining = 0;
    const initialSecondsWorked = this.secondsWorkedOnCurrentTask;
    this.sessionStartSeconds = this.secondsWorkedOnCurrentTask;
    let alertShown = false;
    this.refreshView();
    this.updateStatusBar();
    this.timerInterval = window.setInterval(() => {
      const now = Date.now();
      const elapsedMs = now - this.timerStartTimestamp;
      const elapsedSeconds = Math.floor(elapsedMs / 1e3);
      this.currentTimerSeconds = elapsedSeconds;
      this.secondsWorkedOnCurrentTask = initialSecondsWorked + elapsedSeconds;
      task.actualMinutes = Math.floor(this.secondsWorkedOnCurrentTask / 60);
      this.updateStatusBar();
      this.updateTimerDisplay();
      if (!alertShown && this.currentTimerSeconds >= task.estimatedMinutes * 60) {
        alertShown = true;
        if (this.settings.enableSounds) {
          this.playAlertSound();
        }
        new import_obsidian4.Notice(`\u23F0 Time's up for: ${task.text}`);
      }
    }, 1e3);
    this.saveAllData();
  }
  startPomodoro(taskId) {
    const task = this.data.tasks.find((t) => t.id === taskId);
    if (!task)
      return;
    this.stopTimer(true);
    this.activeTaskId = taskId;
    task.isActive = true;
    this.isBreakMode = false;
    this.isStopwatchMode = false;
    this.currentTimerSeconds = this.settings.pomodoroWorkMinutes * 60;
    this.isTimerRunning = true;
    this.secondsWorkedOnCurrentTask = Math.floor(task.actualMinutes * 60);
    this.timerStartTimestamp = Date.now();
    this.pausedTimeRemaining = this.currentTimerSeconds;
    const initialSecondsWorked = this.secondsWorkedOnCurrentTask;
    this.sessionStartSeconds = this.secondsWorkedOnCurrentTask;
    this.refreshView();
    this.updateStatusBar();
    this.timerInterval = window.setInterval(() => {
      const now = Date.now();
      const elapsedMs = now - this.timerStartTimestamp;
      const elapsedSeconds = Math.floor(elapsedMs / 1e3);
      this.currentTimerSeconds = Math.max(0, this.pausedTimeRemaining - elapsedSeconds);
      if (!this.isBreakMode) {
        this.secondsWorkedOnCurrentTask = initialSecondsWorked + elapsedSeconds;
        const actualMinutes = Math.floor(this.secondsWorkedOnCurrentTask / 60);
        if (task.actualMinutes !== actualMinutes) {
          task.actualMinutes = actualMinutes;
        }
      }
      this.updateStatusBar();
      this.updateTimerDisplay();
      if (this.currentTimerSeconds <= 0) {
        this.handlePomodoroEnd();
      }
    }, 1e3);
  }
  handlePomodoroEnd() {
    if (this.timerInterval) {
      window.clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
    this.currentTimerSeconds = 0;
    this.isTimerRunning = false;
    this.updateStatusBar();
    this.updateTimerDisplay();
    if (!this.isBreakMode) {
      this.pomodoroCount++;
      this.data.pomodorosCompleted++;
      if (this.settings.enableSounds) {
        this.playAlertSound();
      }
      new import_obsidian4.Notice("\u{1F345} Pomodoro complete! Time for a break.");
      if (this.settings.autoStartBreak) {
        this.startBreak();
      } else {
        this.refreshView();
      }
    } else {
      if (this.settings.enableSounds) {
        this.playAlertSound();
      }
      new import_obsidian4.Notice("\u26A1 Break over! Ready to focus?");
      this.refreshView();
    }
    this.saveAllData();
  }
  startBreak() {
    this.isBreakMode = true;
    this.isTimerRunning = true;
    const isLongBreak = this.pomodoroCount % this.settings.longBreakInterval === 0;
    this.currentTimerSeconds = (isLongBreak ? this.settings.longBreakMinutes : this.settings.pomodoroBreakMinutes) * 60;
    this.timerStartTimestamp = Date.now();
    this.pausedTimeRemaining = this.currentTimerSeconds;
    new import_obsidian4.Notice(isLongBreak ? "\u2615 Long break time!" : "\u2615 Short break time!");
    this.refreshView();
    if (!this.timerInterval) {
      this.timerInterval = window.setInterval(() => {
        const now = Date.now();
        const elapsedMs = now - this.timerStartTimestamp;
        const elapsedSeconds = Math.floor(elapsedMs / 1e3);
        this.currentTimerSeconds = Math.max(0, this.pausedTimeRemaining - elapsedSeconds);
        this.updateStatusBar();
        this.updateTimerDisplay();
        if (this.currentTimerSeconds <= 0) {
          this.handlePomodoroEnd();
        }
      }, 1e3);
    }
    this.updateStatusBar();
  }
  toggleTimer() {
    if (this.isTimerRunning && this.timerInterval) {
      window.clearInterval(this.timerInterval);
      this.timerInterval = null;
      this.isTimerRunning = false;
      this.pausedTimeRemaining = this.currentTimerSeconds;
    } else if (this.activeTaskId) {
      this.isTimerRunning = true;
      this.timerStartTimestamp = Date.now();
      const task = this.data.tasks.find((t) => t.id === this.activeTaskId);
      const initialSecondsWorked = this.secondsWorkedOnCurrentTask;
      this.timerInterval = window.setInterval(() => {
        const now = Date.now();
        const elapsedMs = now - this.timerStartTimestamp;
        const elapsedSeconds = Math.floor(elapsedMs / 1e3);
        if (this.pausedTimeRemaining === 0 || this.isStopwatchMode) {
          this.currentTimerSeconds = this.pausedTimeRemaining + elapsedSeconds;
        } else {
          this.currentTimerSeconds = Math.max(0, this.pausedTimeRemaining - elapsedSeconds);
        }
        if (task && !this.isBreakMode) {
          this.secondsWorkedOnCurrentTask = initialSecondsWorked + elapsedSeconds;
          task.actualMinutes = Math.floor(this.secondsWorkedOnCurrentTask / 60);
        }
        this.updateStatusBar();
        this.updateTimerDisplay();
        if (this.currentTimerSeconds <= 0 && !this.isStopwatchMode) {
          this.handlePomodoroEnd();
        }
      }, 1e3);
    } else {
      new import_obsidian4.Notice("No active task. Select a task first.");
    }
    this.updateStatusBar();
    this.refreshView();
  }
  stopTimer(preserveActualTime = false) {
    if (this.timerInterval) {
      window.clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
    if (this.activeTaskId) {
      const task = this.data.tasks.find((t) => t.id === this.activeTaskId);
      if (task) {
        task.isActive = false;
        if (!preserveActualTime) {
          task.actualMinutes = 0;
        }
      }
    }
    this.isTimerRunning = false;
    this.isStopwatchMode = false;
    this.activeTaskId = null;
    this.secondsWorkedOnCurrentTask = 0;
    this.sessionStartSeconds = 0;
    this.timerStartTimestamp = 0;
    this.pausedTimeRemaining = 0;
    this.updateStatusBar();
    this.saveAllData();
    this.refreshView();
  }
  startFocusOnNextTask() {
    const pendingTasks = this.data.tasks.filter((t) => !t.completed);
    if (pendingTasks.length > 0) {
      this.startPomodoro(pendingTasks[0].id);
    } else {
      new import_obsidian4.Notice("No pending tasks. Add a task first!");
    }
  }
  // ============ Status Bar Timer ============
  createStatusBar() {
    this.statusBarEl = this.addStatusBarItem();
    this.statusBarEl.addClass("immerse-status-bar");
    this.updateStatusBar();
    this.statusBarEl.addEventListener("click", () => {
      this.activateView();
    });
  }
  updateStatusBar() {
    if (!this.statusBarEl)
      return;
    if (this.activeTaskId) {
      const task = this.data.tasks.find((t) => t.id === this.activeTaskId);
      const taskName = this.isBreakMode ? "\u2615 Break" : (task == null ? void 0 : task.text.substring(0, 20)) || "Task";
      const timeStr = this.formatTime(this.currentTimerSeconds);
      const icon = this.isTimerRunning ? "\u25B6" : "\u23F8";
      this.statusBarEl.setText(`\u26A1 ${icon} ${timeStr} - ${taskName}${task && task.text.length > 20 ? "..." : ""}`);
      this.statusBarEl.addClass("immerse-status-active");
    } else {
      this.statusBarEl.setText("\u26A1 Immerse");
      this.statusBarEl.removeClass("immerse-status-active");
    }
  }
  // ============ Reminder System ============
  startReminderSystem() {
    this.reminderCheckInterval = window.setInterval(() => {
      this.checkReminders();
    }, 3e4);
    this.checkReminders();
  }
  stopReminderSystem() {
    if (this.reminderCheckInterval) {
      window.clearInterval(this.reminderCheckInterval);
      this.reminderCheckInterval = null;
    }
  }
  checkReminders() {
    if (!this.settings.enableReminders)
      return;
    const now = new Date();
    const currentTime = now.getTime();
    this.data.tasks.filter((task) => !task.completed && task.scheduledDate && task.scheduledTime).forEach((task) => {
      const reminderKey = `${task.id}-${task.scheduledDate}-${task.scheduledTime}`;
      if (this.notifiedReminders.has(reminderKey))
        return;
      const scheduledDateTime = new Date(`${task.scheduledDate}T${task.scheduledTime}`);
      const scheduledTime = scheduledDateTime.getTime();
      if (currentTime > scheduledTime) {
        this.showOverdueNotice(task);
        this.notifiedReminders.add(reminderKey);
        return;
      }
      if (task.reminderMinutes) {
        const reminderTime = scheduledTime - task.reminderMinutes * 60 * 1e3;
        if (currentTime >= reminderTime) {
          this.showReminder(task);
          this.notifiedReminders.add(reminderKey);
        }
      }
    });
  }
  showReminder(task) {
    const timeStr = task.scheduledTime;
    new import_obsidian4.Notice(`\u{1F514} Reminder: "${task.text}" is scheduled for ${timeStr}`, 8e3);
    if (this.settings.enableSounds) {
      this.playAlertSound();
    }
  }
  showOverdueNotice(task) {
    const dateStr = task.scheduledDate;
    const timeStr = task.scheduledTime;
    new import_obsidian4.Notice(`\u26A0\uFE0F Overdue: "${task.text}" was scheduled for ${dateStr} ${timeStr}`, 1e4);
    if (this.settings.enableSounds) {
      this.playAlertSound();
    }
  }
  // ============ Sounds & Celebrations ============
  showCelebration(task) {
    let messages = CELEBRATION_MESSAGES;
    let extraMessage = "";
    if (task.actualMinutes < task.estimatedMinutes) {
      const saved = task.estimatedMinutes - task.actualMinutes;
      messages = EARLY_FINISH_MESSAGES;
      extraMessage = ` (${saved} min early!)`;
    } else if (task.actualMinutes > task.estimatedMinutes * 1.5) {
      messages = OVERTIME_MESSAGES;
    }
    const celebration = messages[Math.floor(Math.random() * messages.length)];
    new import_obsidian4.Notice(`${celebration.emoji} ${celebration.message}${extraMessage}`);
  }
  playCompletionSound() {
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
      oscillator.frequency.setValueAtTime(1e3, audioContext.currentTime + 0.1);
      oscillator.frequency.setValueAtTime(1200, audioContext.currentTime + 0.2);
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.3);
    } catch (e) {
      console.log("Audio not available");
    }
  }
  playAlertSound() {
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      for (let i = 0; i < 3; i++) {
        oscillator.frequency.setValueAtTime(440, audioContext.currentTime + i * 0.3);
        oscillator.frequency.setValueAtTime(550, audioContext.currentTime + i * 0.3 + 0.15);
      }
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.9);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.9);
    } catch (e) {
      console.log("Audio not available");
    }
  }
  // ============ Daily Note Logging ============
  async logTaskToDailyNote(task) {
    try {
      const list = this.settings.lists.find((l) => l.id === task.list);
      const timeDiff = task.actualMinutes - task.estimatedMinutes;
      let timeComparison = "";
      if (timeDiff < 0) {
        timeComparison = `${Math.abs(timeDiff)}min under estimate \u2728`;
      } else if (timeDiff > 0) {
        timeComparison = `${timeDiff}min over estimate`;
      } else {
        timeComparison = `exactly on target \u{1F3AF}`;
      }
      const completedTime = new Date(task.completedAt || Date.now()).toLocaleTimeString("en-US", {
        hour: "2-digit",
        minute: "2-digit",
        hour12: false
      });
      const taskEntry = `- [x] ${task.text} | ${(list == null ? void 0 : list.icon) || "\u{1F4CB}"} ${(list == null ? void 0 : list.name) || "Task"} | \u23F1\uFE0F ${this.formatTimeHuman(task.actualMinutes)} / ${this.formatTimeHuman(task.estimatedMinutes)} (${timeComparison}) | \u2705 ${completedTime}`;
      await this.appendToDailyNote(taskEntry);
    } catch (e) {
      console.error("Failed to log task to daily note:", e);
      new import_obsidian4.Notice("Failed to log task to daily note. Make sure Daily Notes core plugin is enabled.");
    }
  }
  getDailyNoteSettings() {
    var _a, _b, _c;
    const dailyNotesPlugin = (_b = (_a = this.app.internalPlugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["daily-notes"];
    if (!(dailyNotesPlugin == null ? void 0 : dailyNotesPlugin.enabled)) {
      return null;
    }
    const settings = (_c = dailyNotesPlugin.instance) == null ? void 0 : _c.options;
    return {
      folder: (settings == null ? void 0 : settings.folder) || "",
      format: (settings == null ? void 0 : settings.format) || "YYYY-MM-DD",
      template: (settings == null ? void 0 : settings.template) || ""
    };
  }
  formatDailyNoteDate(format) {
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth() + 1;
    const day = now.getDate();
    let result = format;
    result = result.replace(/YYYY/g, year.toString());
    result = result.replace(/YY/g, year.toString().slice(-2));
    result = result.replace(/MMMM/g, now.toLocaleDateString("en-US", { month: "long" }));
    result = result.replace(/MMM/g, now.toLocaleDateString("en-US", { month: "short" }));
    result = result.replace(/MM/g, month.toString().padStart(2, "0"));
    result = result.replace(/(?<![A-Za-z])M(?![A-Za-z])/g, month.toString());
    result = result.replace(/dddd/g, now.toLocaleDateString("en-US", { weekday: "long" }));
    result = result.replace(/ddd/g, now.toLocaleDateString("en-US", { weekday: "short" }));
    result = result.replace(/DD/g, day.toString().padStart(2, "0"));
    result = result.replace(/(?<![A-Za-z])D(?![A-Za-z])/g, day.toString());
    return result;
  }
  async getOrCreateDailyNote() {
    const { vault } = this.app;
    const dailySettings = this.getDailyNoteSettings();
    if (!dailySettings) {
      new import_obsidian4.Notice("Daily Notes core plugin is not enabled. Please enable it in Settings \u2192 Core plugins.");
      return null;
    }
    const filename = this.formatDailyNoteDate(dailySettings.format);
    const folder = dailySettings.folder ? `${dailySettings.folder}/` : "";
    const path = `${folder}${filename}.md`;
    let file = vault.getAbstractFileByPath(path);
    if (file && file instanceof import_obsidian4.TFile) {
      return file;
    }
    try {
      if (dailySettings.folder) {
        const folderExists = vault.getAbstractFileByPath(dailySettings.folder);
        if (!folderExists) {
          await vault.createFolder(dailySettings.folder);
        }
      }
      let content = "";
      if (dailySettings.template) {
        const templatePath = dailySettings.template.endsWith(".md") ? dailySettings.template : `${dailySettings.template}.md`;
        const templateFile = vault.getAbstractFileByPath(templatePath);
        if (templateFile && templateFile instanceof import_obsidian4.TFile) {
          content = await vault.read(templateFile);
          content = content.replace(/{{date}}/g, filename).replace(/{{time}}/g, new Date().toLocaleTimeString()).replace(/{{title}}/g, filename);
        }
      }
      const newFile = await vault.create(path, content);
      new import_obsidian4.Notice(`\u{1F4DD} Created daily note: ${filename}`);
      return newFile;
    } catch (e) {
      console.error("Failed to create daily note:", e);
      new import_obsidian4.Notice("Failed to create daily note");
      return null;
    }
  }
  async appendToDailyNote(content) {
    const file = await this.getOrCreateDailyNote();
    if (!file) {
      return;
    }
    const { vault } = this.app;
    const existingContent = await vault.read(file);
    const newContent = existingContent.trimEnd() + "\n" + content + "\n";
    await vault.modify(file, newContent);
    new import_obsidian4.Notice("\u{1F4DD} Task logged to daily note");
  }
  // ============ Utilities ============
  formatTime(seconds) {
    const absSeconds = Math.abs(seconds);
    const mins = Math.floor(absSeconds / 60);
    const secs = absSeconds % 60;
    const sign = seconds < 0 ? "-" : "";
    return `${sign}${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
  }
  formatTimeHuman(minutes) {
    if (minutes < 60)
      return `${minutes}min`;
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    return mins > 0 ? `${hours}hr ${mins}min` : `${hours}hr`;
  }
  refreshView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_IMMERSE);
    leaves.forEach((leaf) => {
      if (leaf.view instanceof ImmerseView) {
        leaf.view.refresh();
      }
    });
  }
  // Light refresh - only updates timer display without rebuilding DOM
  updateTimerDisplay() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_IMMERSE);
    leaves.forEach((leaf) => {
      if (leaf.view instanceof ImmerseView) {
        leaf.view.updateTimerDisplay();
      }
    });
  }
  getTasksByList(listId) {
    return this.data.tasks.filter((t) => t.list === listId);
  }
  getPendingTasks() {
    return this.data.tasks.filter((t) => !t.completed);
  }
  getTodaysTasks() {
    const today = new Date().toDateString();
    return this.data.tasks.filter((t) => {
      if (t.scheduledDate === today)
        return true;
      if (!t.scheduledDate && !t.completed)
        return true;
      return false;
    });
  }
  getStats() {
    const pending = this.getPendingTasks();
    const totalEstimate = pending.reduce((sum, t) => sum + t.estimatedMinutes, 0);
    const completedTasks = this.data.tasks.filter((t) => t.completed);
    const avgAccuracy = completedTasks.length > 0 ? completedTasks.reduce((sum, t) => sum + t.estimatedMinutes / Math.max(t.actualMinutes, 1), 0) / completedTasks.length : 1;
    return {
      pendingCount: pending.length,
      completedToday: this.data.completedToday,
      totalEstimatedMinutes: totalEstimate,
      totalFocusMinutesToday: Math.floor(this.focusSecondsToday / 60),
      streak: this.data.streak,
      pomodorosCompleted: this.data.pomodorosCompleted,
      avgAccuracy: Math.round(avgAccuracy * 100)
    };
  }
};
var ImmerseSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "\u26A1 Immerse Settings" });
    containerEl.createEl("h2", { text: "\u{1F345} Pomodoro Timer" });
    new import_obsidian4.Setting(containerEl).setName("Work Duration").setDesc("Length of each work session in minutes").addSlider((slider) => slider.setLimits(5, 60, 5).setValue(this.plugin.settings.pomodoroWorkMinutes).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.pomodoroWorkMinutes = value;
      await this.plugin.saveAllData();
    }));
    new import_obsidian4.Setting(containerEl).setName("Short Break Duration").setDesc("Length of short breaks in minutes").addSlider((slider) => slider.setLimits(1, 15, 1).setValue(this.plugin.settings.pomodoroBreakMinutes).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.pomodoroBreakMinutes = value;
      await this.plugin.saveAllData();
    }));
    new import_obsidian4.Setting(containerEl).setName("Long Break Duration").setDesc("Length of long breaks in minutes").addSlider((slider) => slider.setLimits(5, 30, 5).setValue(this.plugin.settings.longBreakMinutes).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.longBreakMinutes = value;
      await this.plugin.saveAllData();
    }));
    new import_obsidian4.Setting(containerEl).setName("Long Break Interval").setDesc("Number of pomodoros before a long break").addSlider((slider) => slider.setLimits(2, 6, 1).setValue(this.plugin.settings.longBreakInterval).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.longBreakInterval = value;
      await this.plugin.saveAllData();
    }));
    new import_obsidian4.Setting(containerEl).setName("Auto-start Breaks").setDesc("Automatically start break timer after work session").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoStartBreak).onChange(async (value) => {
      this.plugin.settings.autoStartBreak = value;
      await this.plugin.saveAllData();
    }));
    containerEl.createEl("h2", { text: "\u2699\uFE0F General" });
    new import_obsidian4.Setting(containerEl).setName("Default Time Estimate").setDesc("Default estimated time for new tasks in minutes").addSlider((slider) => slider.setLimits(5, 120, 5).setValue(this.plugin.settings.defaultEstimateMinutes).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.defaultEstimateMinutes = value;
      await this.plugin.saveAllData();
    }));
    new import_obsidian4.Setting(containerEl).setName("Enable Sounds").setDesc("Play sounds for timer completion and task completion").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableSounds).onChange(async (value) => {
      this.plugin.settings.enableSounds = value;
      await this.plugin.saveAllData();
    }));
    new import_obsidian4.Setting(containerEl).setName("Enable Celebrations").setDesc("Show celebration messages when completing tasks").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableCelebrations).onChange(async (value) => {
      this.plugin.settings.enableCelebrations = value;
      await this.plugin.saveAllData();
    }));
    containerEl.createEl("h2", { text: "\u{1F4DD} Daily Note Integration" });
    new import_obsidian4.Setting(containerEl).setName("Log completed tasks to daily note").setDesc("When you complete a task, add an entry to your daily note. Uses the core Daily Notes plugin settings.").addToggle((toggle) => toggle.setValue(this.plugin.settings.logToDaily).onChange(async (value) => {
      this.plugin.settings.logToDaily = value;
      await this.plugin.saveAllData();
    }));
    const infoEl = containerEl.createEl("div", { cls: "setting-item-description" });
    infoEl.style.marginTop = "-10px";
    infoEl.style.marginBottom = "20px";
    infoEl.innerHTML = `
			<small>
				This feature uses the <strong>Daily Notes</strong> core plugin. 
				Configure your daily note folder, date format, and template in 
				<em>Settings \u2192 Core plugins \u2192 Daily notes</em>.
			</small>
		`;
    containerEl.createEl("h2", { text: "\u{1F4CB} Lists" });
    this.plugin.settings.lists.forEach((list, index) => {
      new import_obsidian4.Setting(containerEl).setName(`${list.icon} ${list.name}`).addText((text) => text.setValue(list.name).setPlaceholder("List name").onChange(async (value) => {
        this.plugin.settings.lists[index].name = value;
        await this.plugin.saveAllData();
      })).addButton((btn) => btn.setButtonText(list.icon || "\u{1F4C1}").setTooltip("Choose emoji").onClick(() => {
        const modal = new EmojiPickerModal(
          this.app,
          list.icon,
          async (emoji) => {
            this.plugin.settings.lists[index].icon = emoji;
            await this.plugin.saveAllData();
            this.display();
          }
        );
        modal.open();
      })).addColorPicker((picker) => picker.setValue(list.color).onChange(async (value) => {
        this.plugin.settings.lists[index].color = value;
        await this.plugin.saveAllData();
      })).addButton((btn) => btn.setIcon("trash").setTooltip("Delete list").onClick(async () => {
        this.plugin.settings.lists.splice(index, 1);
        await this.plugin.saveAllData();
        this.display();
      }));
    });
    new import_obsidian4.Setting(containerEl).addButton((btn) => btn.setButtonText("+ Add List").onClick(async () => {
      this.plugin.settings.lists.push({
        id: this.plugin.generateId(),
        name: "New List",
        color: "#6366f1",
        icon: "\u{1F4C1}"
      });
      await this.plugin.saveAllData();
      this.display();
    }));
    containerEl.createEl("h2", { text: "\u{1F4D6} About" });
    const aboutDiv = containerEl.createDiv({ cls: "immerse-about" });
    aboutDiv.innerHTML = `
			<p><strong>Immerse</strong> is heavily inspired by <a href="https://www.blitzit.app/">Blitzit</a>,
			a fantastic productivity app that combines task management with focused time tracking.</p>
			<p>This plugin brings similar functionality directly into Obsidian, allowing you to manage tasks,
			use the Pomodoro technique, and track your productivity without leaving your notes.</p>
			<p>
				<a href="https://git.cribdev.com/crib/immerse">Source Code</a>
			</p>
		`;
  }
};
